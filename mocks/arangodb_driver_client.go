// Code generated by mockery v2.40.3. DO NOT EDIT.

package mocks

import (
	arangodb "github.com/arangodb/go-driver/v2/arangodb"
	connection "github.com/arangodb/go-driver/v2/connection"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// AccessibleDatabases provides a mock function with given fields: ctx
func (_m *Client) AccessibleDatabases(ctx context.Context) ([]arangodb.Database, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AccessibleDatabases")
	}

	var r0 []arangodb.Database
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]arangodb.Database, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []arangodb.Database); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]arangodb.Database)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_AccessibleDatabases_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccessibleDatabases'
type Client_AccessibleDatabases_Call struct {
	*mock.Call
}

// AccessibleDatabases is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) AccessibleDatabases(ctx interface{}) *Client_AccessibleDatabases_Call {
	return &Client_AccessibleDatabases_Call{Call: _e.mock.On("AccessibleDatabases", ctx)}
}

func (_c *Client_AccessibleDatabases_Call) Run(run func(ctx context.Context)) *Client_AccessibleDatabases_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_AccessibleDatabases_Call) Return(_a0 []arangodb.Database, _a1 error) *Client_AccessibleDatabases_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_AccessibleDatabases_Call) RunAndReturn(run func(context.Context) ([]arangodb.Database, error)) *Client_AccessibleDatabases_Call {
	_c.Call.Return(run)
	return _c
}

// AsyncJobCancel provides a mock function with given fields: ctx, jobID
func (_m *Client) AsyncJobCancel(ctx context.Context, jobID string) (bool, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for AsyncJobCancel")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, jobID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_AsyncJobCancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AsyncJobCancel'
type Client_AsyncJobCancel_Call struct {
	*mock.Call
}

// AsyncJobCancel is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID string
func (_e *Client_Expecter) AsyncJobCancel(ctx interface{}, jobID interface{}) *Client_AsyncJobCancel_Call {
	return &Client_AsyncJobCancel_Call{Call: _e.mock.On("AsyncJobCancel", ctx, jobID)}
}

func (_c *Client_AsyncJobCancel_Call) Run(run func(ctx context.Context, jobID string)) *Client_AsyncJobCancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_AsyncJobCancel_Call) Return(_a0 bool, _a1 error) *Client_AsyncJobCancel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_AsyncJobCancel_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *Client_AsyncJobCancel_Call {
	_c.Call.Return(run)
	return _c
}

// AsyncJobDelete provides a mock function with given fields: ctx, deleteType, opts
func (_m *Client) AsyncJobDelete(ctx context.Context, deleteType arangodb.AsyncJobDeleteType, opts *arangodb.AsyncJobDeleteOptions) (bool, error) {
	ret := _m.Called(ctx, deleteType, opts)

	if len(ret) == 0 {
		panic("no return value specified for AsyncJobDelete")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.AsyncJobDeleteType, *arangodb.AsyncJobDeleteOptions) (bool, error)); ok {
		return rf(ctx, deleteType, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.AsyncJobDeleteType, *arangodb.AsyncJobDeleteOptions) bool); ok {
		r0 = rf(ctx, deleteType, opts)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, arangodb.AsyncJobDeleteType, *arangodb.AsyncJobDeleteOptions) error); ok {
		r1 = rf(ctx, deleteType, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_AsyncJobDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AsyncJobDelete'
type Client_AsyncJobDelete_Call struct {
	*mock.Call
}

// AsyncJobDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - deleteType arangodb.AsyncJobDeleteType
//   - opts *arangodb.AsyncJobDeleteOptions
func (_e *Client_Expecter) AsyncJobDelete(ctx interface{}, deleteType interface{}, opts interface{}) *Client_AsyncJobDelete_Call {
	return &Client_AsyncJobDelete_Call{Call: _e.mock.On("AsyncJobDelete", ctx, deleteType, opts)}
}

func (_c *Client_AsyncJobDelete_Call) Run(run func(ctx context.Context, deleteType arangodb.AsyncJobDeleteType, opts *arangodb.AsyncJobDeleteOptions)) *Client_AsyncJobDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.AsyncJobDeleteType), args[2].(*arangodb.AsyncJobDeleteOptions))
	})
	return _c
}

func (_c *Client_AsyncJobDelete_Call) Return(_a0 bool, _a1 error) *Client_AsyncJobDelete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_AsyncJobDelete_Call) RunAndReturn(run func(context.Context, arangodb.AsyncJobDeleteType, *arangodb.AsyncJobDeleteOptions) (bool, error)) *Client_AsyncJobDelete_Call {
	_c.Call.Return(run)
	return _c
}

// AsyncJobList provides a mock function with given fields: ctx, jobType, opts
func (_m *Client) AsyncJobList(ctx context.Context, jobType arangodb.AsyncJobStatusType, opts *arangodb.AsyncJobListOptions) ([]string, error) {
	ret := _m.Called(ctx, jobType, opts)

	if len(ret) == 0 {
		panic("no return value specified for AsyncJobList")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.AsyncJobStatusType, *arangodb.AsyncJobListOptions) ([]string, error)); ok {
		return rf(ctx, jobType, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.AsyncJobStatusType, *arangodb.AsyncJobListOptions) []string); ok {
		r0 = rf(ctx, jobType, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, arangodb.AsyncJobStatusType, *arangodb.AsyncJobListOptions) error); ok {
		r1 = rf(ctx, jobType, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_AsyncJobList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AsyncJobList'
type Client_AsyncJobList_Call struct {
	*mock.Call
}

// AsyncJobList is a helper method to define mock.On call
//   - ctx context.Context
//   - jobType arangodb.AsyncJobStatusType
//   - opts *arangodb.AsyncJobListOptions
func (_e *Client_Expecter) AsyncJobList(ctx interface{}, jobType interface{}, opts interface{}) *Client_AsyncJobList_Call {
	return &Client_AsyncJobList_Call{Call: _e.mock.On("AsyncJobList", ctx, jobType, opts)}
}

func (_c *Client_AsyncJobList_Call) Run(run func(ctx context.Context, jobType arangodb.AsyncJobStatusType, opts *arangodb.AsyncJobListOptions)) *Client_AsyncJobList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.AsyncJobStatusType), args[2].(*arangodb.AsyncJobListOptions))
	})
	return _c
}

func (_c *Client_AsyncJobList_Call) Return(_a0 []string, _a1 error) *Client_AsyncJobList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_AsyncJobList_Call) RunAndReturn(run func(context.Context, arangodb.AsyncJobStatusType, *arangodb.AsyncJobListOptions) ([]string, error)) *Client_AsyncJobList_Call {
	_c.Call.Return(run)
	return _c
}

// AsyncJobStatus provides a mock function with given fields: ctx, jobID
func (_m *Client) AsyncJobStatus(ctx context.Context, jobID string) (arangodb.AsyncJobStatusType, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for AsyncJobStatus")
	}

	var r0 arangodb.AsyncJobStatusType
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (arangodb.AsyncJobStatusType, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) arangodb.AsyncJobStatusType); ok {
		r0 = rf(ctx, jobID)
	} else {
		r0 = ret.Get(0).(arangodb.AsyncJobStatusType)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_AsyncJobStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AsyncJobStatus'
type Client_AsyncJobStatus_Call struct {
	*mock.Call
}

// AsyncJobStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID string
func (_e *Client_Expecter) AsyncJobStatus(ctx interface{}, jobID interface{}) *Client_AsyncJobStatus_Call {
	return &Client_AsyncJobStatus_Call{Call: _e.mock.On("AsyncJobStatus", ctx, jobID)}
}

func (_c *Client_AsyncJobStatus_Call) Run(run func(ctx context.Context, jobID string)) *Client_AsyncJobStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_AsyncJobStatus_Call) Return(_a0 arangodb.AsyncJobStatusType, _a1 error) *Client_AsyncJobStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_AsyncJobStatus_Call) RunAndReturn(run func(context.Context, string) (arangodb.AsyncJobStatusType, error)) *Client_AsyncJobStatus_Call {
	_c.Call.Return(run)
	return _c
}

// BackupCreate provides a mock function with given fields: ctx, opt
func (_m *Client) BackupCreate(ctx context.Context, opt *arangodb.BackupCreateOptions) (arangodb.BackupResponse, error) {
	ret := _m.Called(ctx, opt)

	if len(ret) == 0 {
		panic("no return value specified for BackupCreate")
	}

	var r0 arangodb.BackupResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *arangodb.BackupCreateOptions) (arangodb.BackupResponse, error)); ok {
		return rf(ctx, opt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *arangodb.BackupCreateOptions) arangodb.BackupResponse); ok {
		r0 = rf(ctx, opt)
	} else {
		r0 = ret.Get(0).(arangodb.BackupResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *arangodb.BackupCreateOptions) error); ok {
		r1 = rf(ctx, opt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_BackupCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BackupCreate'
type Client_BackupCreate_Call struct {
	*mock.Call
}

// BackupCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - opt *arangodb.BackupCreateOptions
func (_e *Client_Expecter) BackupCreate(ctx interface{}, opt interface{}) *Client_BackupCreate_Call {
	return &Client_BackupCreate_Call{Call: _e.mock.On("BackupCreate", ctx, opt)}
}

func (_c *Client_BackupCreate_Call) Run(run func(ctx context.Context, opt *arangodb.BackupCreateOptions)) *Client_BackupCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*arangodb.BackupCreateOptions))
	})
	return _c
}

func (_c *Client_BackupCreate_Call) Return(_a0 arangodb.BackupResponse, _a1 error) *Client_BackupCreate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_BackupCreate_Call) RunAndReturn(run func(context.Context, *arangodb.BackupCreateOptions) (arangodb.BackupResponse, error)) *Client_BackupCreate_Call {
	_c.Call.Return(run)
	return _c
}

// BackupDelete provides a mock function with given fields: ctx, id
func (_m *Client) BackupDelete(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for BackupDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_BackupDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BackupDelete'
type Client_BackupDelete_Call struct {
	*mock.Call
}

// BackupDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Client_Expecter) BackupDelete(ctx interface{}, id interface{}) *Client_BackupDelete_Call {
	return &Client_BackupDelete_Call{Call: _e.mock.On("BackupDelete", ctx, id)}
}

func (_c *Client_BackupDelete_Call) Run(run func(ctx context.Context, id string)) *Client_BackupDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_BackupDelete_Call) Return(_a0 error) *Client_BackupDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_BackupDelete_Call) RunAndReturn(run func(context.Context, string) error) *Client_BackupDelete_Call {
	_c.Call.Return(run)
	return _c
}

// BackupDownload provides a mock function with given fields: ctx, backupId, remoteRepository, config
func (_m *Client) BackupDownload(ctx context.Context, backupId string, remoteRepository string, config interface{}) (arangodb.TransferMonitor, error) {
	ret := _m.Called(ctx, backupId, remoteRepository, config)

	if len(ret) == 0 {
		panic("no return value specified for BackupDownload")
	}

	var r0 arangodb.TransferMonitor
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) (arangodb.TransferMonitor, error)); ok {
		return rf(ctx, backupId, remoteRepository, config)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) arangodb.TransferMonitor); ok {
		r0 = rf(ctx, backupId, remoteRepository, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.TransferMonitor)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, interface{}) error); ok {
		r1 = rf(ctx, backupId, remoteRepository, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_BackupDownload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BackupDownload'
type Client_BackupDownload_Call struct {
	*mock.Call
}

// BackupDownload is a helper method to define mock.On call
//   - ctx context.Context
//   - backupId string
//   - remoteRepository string
//   - config interface{}
func (_e *Client_Expecter) BackupDownload(ctx interface{}, backupId interface{}, remoteRepository interface{}, config interface{}) *Client_BackupDownload_Call {
	return &Client_BackupDownload_Call{Call: _e.mock.On("BackupDownload", ctx, backupId, remoteRepository, config)}
}

func (_c *Client_BackupDownload_Call) Run(run func(ctx context.Context, backupId string, remoteRepository string, config interface{})) *Client_BackupDownload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *Client_BackupDownload_Call) Return(_a0 arangodb.TransferMonitor, _a1 error) *Client_BackupDownload_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_BackupDownload_Call) RunAndReturn(run func(context.Context, string, string, interface{}) (arangodb.TransferMonitor, error)) *Client_BackupDownload_Call {
	_c.Call.Return(run)
	return _c
}

// BackupList provides a mock function with given fields: ctx, opt
func (_m *Client) BackupList(ctx context.Context, opt *arangodb.BackupListOptions) (arangodb.ListBackupsResponse, error) {
	ret := _m.Called(ctx, opt)

	if len(ret) == 0 {
		panic("no return value specified for BackupList")
	}

	var r0 arangodb.ListBackupsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *arangodb.BackupListOptions) (arangodb.ListBackupsResponse, error)); ok {
		return rf(ctx, opt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *arangodb.BackupListOptions) arangodb.ListBackupsResponse); ok {
		r0 = rf(ctx, opt)
	} else {
		r0 = ret.Get(0).(arangodb.ListBackupsResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *arangodb.BackupListOptions) error); ok {
		r1 = rf(ctx, opt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_BackupList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BackupList'
type Client_BackupList_Call struct {
	*mock.Call
}

// BackupList is a helper method to define mock.On call
//   - ctx context.Context
//   - opt *arangodb.BackupListOptions
func (_e *Client_Expecter) BackupList(ctx interface{}, opt interface{}) *Client_BackupList_Call {
	return &Client_BackupList_Call{Call: _e.mock.On("BackupList", ctx, opt)}
}

func (_c *Client_BackupList_Call) Run(run func(ctx context.Context, opt *arangodb.BackupListOptions)) *Client_BackupList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*arangodb.BackupListOptions))
	})
	return _c
}

func (_c *Client_BackupList_Call) Return(_a0 arangodb.ListBackupsResponse, _a1 error) *Client_BackupList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_BackupList_Call) RunAndReturn(run func(context.Context, *arangodb.BackupListOptions) (arangodb.ListBackupsResponse, error)) *Client_BackupList_Call {
	_c.Call.Return(run)
	return _c
}

// BackupRestore provides a mock function with given fields: ctx, id
func (_m *Client) BackupRestore(ctx context.Context, id string) (arangodb.BackupRestoreResponse, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for BackupRestore")
	}

	var r0 arangodb.BackupRestoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (arangodb.BackupRestoreResponse, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) arangodb.BackupRestoreResponse); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(arangodb.BackupRestoreResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_BackupRestore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BackupRestore'
type Client_BackupRestore_Call struct {
	*mock.Call
}

// BackupRestore is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *Client_Expecter) BackupRestore(ctx interface{}, id interface{}) *Client_BackupRestore_Call {
	return &Client_BackupRestore_Call{Call: _e.mock.On("BackupRestore", ctx, id)}
}

func (_c *Client_BackupRestore_Call) Run(run func(ctx context.Context, id string)) *Client_BackupRestore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_BackupRestore_Call) Return(_a0 arangodb.BackupRestoreResponse, _a1 error) *Client_BackupRestore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_BackupRestore_Call) RunAndReturn(run func(context.Context, string) (arangodb.BackupRestoreResponse, error)) *Client_BackupRestore_Call {
	_c.Call.Return(run)
	return _c
}

// BackupUpload provides a mock function with given fields: ctx, backupId, remoteRepository, config
func (_m *Client) BackupUpload(ctx context.Context, backupId string, remoteRepository string, config interface{}) (arangodb.TransferMonitor, error) {
	ret := _m.Called(ctx, backupId, remoteRepository, config)

	if len(ret) == 0 {
		panic("no return value specified for BackupUpload")
	}

	var r0 arangodb.TransferMonitor
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) (arangodb.TransferMonitor, error)); ok {
		return rf(ctx, backupId, remoteRepository, config)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) arangodb.TransferMonitor); ok {
		r0 = rf(ctx, backupId, remoteRepository, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.TransferMonitor)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, interface{}) error); ok {
		r1 = rf(ctx, backupId, remoteRepository, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_BackupUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BackupUpload'
type Client_BackupUpload_Call struct {
	*mock.Call
}

// BackupUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - backupId string
//   - remoteRepository string
//   - config interface{}
func (_e *Client_Expecter) BackupUpload(ctx interface{}, backupId interface{}, remoteRepository interface{}, config interface{}) *Client_BackupUpload_Call {
	return &Client_BackupUpload_Call{Call: _e.mock.On("BackupUpload", ctx, backupId, remoteRepository, config)}
}

func (_c *Client_BackupUpload_Call) Run(run func(ctx context.Context, backupId string, remoteRepository string, config interface{})) *Client_BackupUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *Client_BackupUpload_Call) Return(_a0 arangodb.TransferMonitor, _a1 error) *Client_BackupUpload_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_BackupUpload_Call) RunAndReturn(run func(context.Context, string, string, interface{}) (arangodb.TransferMonitor, error)) *Client_BackupUpload_Call {
	_c.Call.Return(run)
	return _c
}

// CheckAvailability provides a mock function with given fields: ctx, serverEndpoint
func (_m *Client) CheckAvailability(ctx context.Context, serverEndpoint string) error {
	ret := _m.Called(ctx, serverEndpoint)

	if len(ret) == 0 {
		panic("no return value specified for CheckAvailability")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, serverEndpoint)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_CheckAvailability_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckAvailability'
type Client_CheckAvailability_Call struct {
	*mock.Call
}

// CheckAvailability is a helper method to define mock.On call
//   - ctx context.Context
//   - serverEndpoint string
func (_e *Client_Expecter) CheckAvailability(ctx interface{}, serverEndpoint interface{}) *Client_CheckAvailability_Call {
	return &Client_CheckAvailability_Call{Call: _e.mock.On("CheckAvailability", ctx, serverEndpoint)}
}

func (_c *Client_CheckAvailability_Call) Run(run func(ctx context.Context, serverEndpoint string)) *Client_CheckAvailability_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_CheckAvailability_Call) Return(_a0 error) *Client_CheckAvailability_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_CheckAvailability_Call) RunAndReturn(run func(context.Context, string) error) *Client_CheckAvailability_Call {
	_c.Call.Return(run)
	return _c
}

// CleanOutServer provides a mock function with given fields: ctx, serverID
func (_m *Client) CleanOutServer(ctx context.Context, serverID arangodb.ServerID) (string, error) {
	ret := _m.Called(ctx, serverID)

	if len(ret) == 0 {
		panic("no return value specified for CleanOutServer")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.ServerID) (string, error)); ok {
		return rf(ctx, serverID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.ServerID) string); ok {
		r0 = rf(ctx, serverID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, arangodb.ServerID) error); ok {
		r1 = rf(ctx, serverID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_CleanOutServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanOutServer'
type Client_CleanOutServer_Call struct {
	*mock.Call
}

// CleanOutServer is a helper method to define mock.On call
//   - ctx context.Context
//   - serverID arangodb.ServerID
func (_e *Client_Expecter) CleanOutServer(ctx interface{}, serverID interface{}) *Client_CleanOutServer_Call {
	return &Client_CleanOutServer_Call{Call: _e.mock.On("CleanOutServer", ctx, serverID)}
}

func (_c *Client_CleanOutServer_Call) Run(run func(ctx context.Context, serverID arangodb.ServerID)) *Client_CleanOutServer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.ServerID))
	})
	return _c
}

func (_c *Client_CleanOutServer_Call) Return(_a0 string, _a1 error) *Client_CleanOutServer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_CleanOutServer_Call) RunAndReturn(run func(context.Context, arangodb.ServerID) (string, error)) *Client_CleanOutServer_Call {
	_c.Call.Return(run)
	return _c
}

// Connection provides a mock function with given fields:
func (_m *Client) Connection() connection.Connection {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Connection")
	}

	var r0 connection.Connection
	if rf, ok := ret.Get(0).(func() connection.Connection); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(connection.Connection)
		}
	}

	return r0
}

// Client_Connection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connection'
type Client_Connection_Call struct {
	*mock.Call
}

// Connection is a helper method to define mock.On call
func (_e *Client_Expecter) Connection() *Client_Connection_Call {
	return &Client_Connection_Call{Call: _e.mock.On("Connection")}
}

func (_c *Client_Connection_Call) Run(run func()) *Client_Connection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_Connection_Call) Return(_a0 connection.Connection) *Client_Connection_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_Connection_Call) RunAndReturn(run func() connection.Connection) *Client_Connection_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDatabase provides a mock function with given fields: ctx, name, options
func (_m *Client) CreateDatabase(ctx context.Context, name string, options *arangodb.CreateDatabaseOptions) (arangodb.Database, error) {
	ret := _m.Called(ctx, name, options)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatabase")
	}

	var r0 arangodb.Database
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.CreateDatabaseOptions) (arangodb.Database, error)); ok {
		return rf(ctx, name, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.CreateDatabaseOptions) arangodb.Database); ok {
		r0 = rf(ctx, name, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Database)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.CreateDatabaseOptions) error); ok {
		r1 = rf(ctx, name, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_CreateDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDatabase'
type Client_CreateDatabase_Call struct {
	*mock.Call
}

// CreateDatabase is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - options *arangodb.CreateDatabaseOptions
func (_e *Client_Expecter) CreateDatabase(ctx interface{}, name interface{}, options interface{}) *Client_CreateDatabase_Call {
	return &Client_CreateDatabase_Call{Call: _e.mock.On("CreateDatabase", ctx, name, options)}
}

func (_c *Client_CreateDatabase_Call) Run(run func(ctx context.Context, name string, options *arangodb.CreateDatabaseOptions)) *Client_CreateDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.CreateDatabaseOptions))
	})
	return _c
}

func (_c *Client_CreateDatabase_Call) Return(_a0 arangodb.Database, _a1 error) *Client_CreateDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_CreateDatabase_Call) RunAndReturn(run func(context.Context, string, *arangodb.CreateDatabaseOptions) (arangodb.Database, error)) *Client_CreateDatabase_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: ctx, name, options
func (_m *Client) CreateUser(ctx context.Context, name string, options *arangodb.UserOptions) (arangodb.User, error) {
	ret := _m.Called(ctx, name, options)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 arangodb.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.UserOptions) (arangodb.User, error)); ok {
		return rf(ctx, name, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.UserOptions) arangodb.User); ok {
		r0 = rf(ctx, name, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.UserOptions) error); ok {
		r1 = rf(ctx, name, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type Client_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - options *arangodb.UserOptions
func (_e *Client_Expecter) CreateUser(ctx interface{}, name interface{}, options interface{}) *Client_CreateUser_Call {
	return &Client_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, name, options)}
}

func (_c *Client_CreateUser_Call) Run(run func(ctx context.Context, name string, options *arangodb.UserOptions)) *Client_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.UserOptions))
	})
	return _c
}

func (_c *Client_CreateUser_Call) Return(_a0 arangodb.User, _a1 error) *Client_CreateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_CreateUser_Call) RunAndReturn(run func(context.Context, string, *arangodb.UserOptions) (arangodb.User, error)) *Client_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// Database provides a mock function with given fields: ctx, name
func (_m *Client) Database(ctx context.Context, name string) (arangodb.Database, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for Database")
	}

	var r0 arangodb.Database
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (arangodb.Database, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) arangodb.Database); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Database)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Database_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Database'
type Client_Database_Call struct {
	*mock.Call
}

// Database is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Client_Expecter) Database(ctx interface{}, name interface{}) *Client_Database_Call {
	return &Client_Database_Call{Call: _e.mock.On("Database", ctx, name)}
}

func (_c *Client_Database_Call) Run(run func(ctx context.Context, name string)) *Client_Database_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_Database_Call) Return(_a0 arangodb.Database, _a1 error) *Client_Database_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Database_Call) RunAndReturn(run func(context.Context, string) (arangodb.Database, error)) *Client_Database_Call {
	_c.Call.Return(run)
	return _c
}

// DatabaseExists provides a mock function with given fields: ctx, name
func (_m *Client) DatabaseExists(ctx context.Context, name string) (bool, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for DatabaseExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_DatabaseExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DatabaseExists'
type Client_DatabaseExists_Call struct {
	*mock.Call
}

// DatabaseExists is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Client_Expecter) DatabaseExists(ctx interface{}, name interface{}) *Client_DatabaseExists_Call {
	return &Client_DatabaseExists_Call{Call: _e.mock.On("DatabaseExists", ctx, name)}
}

func (_c *Client_DatabaseExists_Call) Run(run func(ctx context.Context, name string)) *Client_DatabaseExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_DatabaseExists_Call) Return(_a0 bool, _a1 error) *Client_DatabaseExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_DatabaseExists_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *Client_DatabaseExists_Call {
	_c.Call.Return(run)
	return _c
}

// DatabaseInventory provides a mock function with given fields: ctx, dbName
func (_m *Client) DatabaseInventory(ctx context.Context, dbName string) (arangodb.DatabaseInventory, error) {
	ret := _m.Called(ctx, dbName)

	if len(ret) == 0 {
		panic("no return value specified for DatabaseInventory")
	}

	var r0 arangodb.DatabaseInventory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (arangodb.DatabaseInventory, error)); ok {
		return rf(ctx, dbName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) arangodb.DatabaseInventory); ok {
		r0 = rf(ctx, dbName)
	} else {
		r0 = ret.Get(0).(arangodb.DatabaseInventory)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dbName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_DatabaseInventory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DatabaseInventory'
type Client_DatabaseInventory_Call struct {
	*mock.Call
}

// DatabaseInventory is a helper method to define mock.On call
//   - ctx context.Context
//   - dbName string
func (_e *Client_Expecter) DatabaseInventory(ctx interface{}, dbName interface{}) *Client_DatabaseInventory_Call {
	return &Client_DatabaseInventory_Call{Call: _e.mock.On("DatabaseInventory", ctx, dbName)}
}

func (_c *Client_DatabaseInventory_Call) Run(run func(ctx context.Context, dbName string)) *Client_DatabaseInventory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_DatabaseInventory_Call) Return(_a0 arangodb.DatabaseInventory, _a1 error) *Client_DatabaseInventory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_DatabaseInventory_Call) RunAndReturn(run func(context.Context, string) (arangodb.DatabaseInventory, error)) *Client_DatabaseInventory_Call {
	_c.Call.Return(run)
	return _c
}

// Databases provides a mock function with given fields: ctx
func (_m *Client) Databases(ctx context.Context) ([]arangodb.Database, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Databases")
	}

	var r0 []arangodb.Database
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]arangodb.Database, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []arangodb.Database); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]arangodb.Database)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Databases_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Databases'
type Client_Databases_Call struct {
	*mock.Call
}

// Databases is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) Databases(ctx interface{}) *Client_Databases_Call {
	return &Client_Databases_Call{Call: _e.mock.On("Databases", ctx)}
}

func (_c *Client_Databases_Call) Run(run func(ctx context.Context)) *Client_Databases_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_Databases_Call) Return(_a0 []arangodb.Database, _a1 error) *Client_Databases_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Databases_Call) RunAndReturn(run func(context.Context) ([]arangodb.Database, error)) *Client_Databases_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, output, urlParts
func (_m *Client) Delete(ctx context.Context, output interface{}, urlParts ...string) (connection.Response, error) {
	_va := make([]interface{}, len(urlParts))
	for _i := range urlParts {
		_va[_i] = urlParts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, output)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 connection.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...string) (connection.Response, error)); ok {
		return rf(ctx, output, urlParts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...string) connection.Response); ok {
		r0 = rf(ctx, output, urlParts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(connection.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}, ...string) error); ok {
		r1 = rf(ctx, output, urlParts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Client_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - output interface{}
//   - urlParts ...string
func (_e *Client_Expecter) Delete(ctx interface{}, output interface{}, urlParts ...interface{}) *Client_Delete_Call {
	return &Client_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{ctx, output}, urlParts...)...)}
}

func (_c *Client_Delete_Call) Run(run func(ctx context.Context, output interface{}, urlParts ...string)) *Client_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Client_Delete_Call) Return(_a0 connection.Response, _a1 error) *Client_Delete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Delete_Call) RunAndReturn(run func(context.Context, interface{}, ...string) (connection.Response, error)) *Client_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, output, urlParts
func (_m *Client) Get(ctx context.Context, output interface{}, urlParts ...string) (connection.Response, error) {
	_va := make([]interface{}, len(urlParts))
	for _i := range urlParts {
		_va[_i] = urlParts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, output)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 connection.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...string) (connection.Response, error)); ok {
		return rf(ctx, output, urlParts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...string) connection.Response); ok {
		r0 = rf(ctx, output, urlParts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(connection.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}, ...string) error); ok {
		r1 = rf(ctx, output, urlParts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Client_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - output interface{}
//   - urlParts ...string
func (_e *Client_Expecter) Get(ctx interface{}, output interface{}, urlParts ...interface{}) *Client_Get_Call {
	return &Client_Get_Call{Call: _e.mock.On("Get",
		append([]interface{}{ctx, output}, urlParts...)...)}
}

func (_c *Client_Get_Call) Run(run func(ctx context.Context, output interface{}, urlParts ...string)) *Client_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Client_Get_Call) Return(_a0 connection.Response, _a1 error) *Client_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Get_Call) RunAndReturn(run func(context.Context, interface{}, ...string) (connection.Response, error)) *Client_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabase provides a mock function with given fields: ctx, name, options
func (_m *Client) GetDatabase(ctx context.Context, name string, options *arangodb.GetDatabaseOptions) (arangodb.Database, error) {
	ret := _m.Called(ctx, name, options)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabase")
	}

	var r0 arangodb.Database
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.GetDatabaseOptions) (arangodb.Database, error)); ok {
		return rf(ctx, name, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.GetDatabaseOptions) arangodb.Database); ok {
		r0 = rf(ctx, name, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Database)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.GetDatabaseOptions) error); ok {
		r1 = rf(ctx, name, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabase'
type Client_GetDatabase_Call struct {
	*mock.Call
}

// GetDatabase is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - options *arangodb.GetDatabaseOptions
func (_e *Client_Expecter) GetDatabase(ctx interface{}, name interface{}, options interface{}) *Client_GetDatabase_Call {
	return &Client_GetDatabase_Call{Call: _e.mock.On("GetDatabase", ctx, name, options)}
}

func (_c *Client_GetDatabase_Call) Run(run func(ctx context.Context, name string, options *arangodb.GetDatabaseOptions)) *Client_GetDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.GetDatabaseOptions))
	})
	return _c
}

func (_c *Client_GetDatabase_Call) Return(_a0 arangodb.Database, _a1 error) *Client_GetDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetDatabase_Call) RunAndReturn(run func(context.Context, string, *arangodb.GetDatabaseOptions) (arangodb.Database, error)) *Client_GetDatabase_Call {
	_c.Call.Return(run)
	return _c
}

// GetLicense provides a mock function with given fields: ctx
func (_m *Client) GetLicense(ctx context.Context) (arangodb.License, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLicense")
	}

	var r0 arangodb.License
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (arangodb.License, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) arangodb.License); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(arangodb.License)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetLicense_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLicense'
type Client_GetLicense_Call struct {
	*mock.Call
}

// GetLicense is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) GetLicense(ctx interface{}) *Client_GetLicense_Call {
	return &Client_GetLicense_Call{Call: _e.mock.On("GetLicense", ctx)}
}

func (_c *Client_GetLicense_Call) Run(run func(ctx context.Context)) *Client_GetLicense_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_GetLicense_Call) Return(_a0 arangodb.License, _a1 error) *Client_GetLicense_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetLicense_Call) RunAndReturn(run func(context.Context) (arangodb.License, error)) *Client_GetLicense_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogLevels provides a mock function with given fields: ctx, opts
func (_m *Client) GetLogLevels(ctx context.Context, opts *arangodb.LogLevelsGetOptions) (arangodb.LogLevels, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetLogLevels")
	}

	var r0 arangodb.LogLevels
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *arangodb.LogLevelsGetOptions) (arangodb.LogLevels, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *arangodb.LogLevelsGetOptions) arangodb.LogLevels); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.LogLevels)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *arangodb.LogLevelsGetOptions) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetLogLevels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogLevels'
type Client_GetLogLevels_Call struct {
	*mock.Call
}

// GetLogLevels is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *arangodb.LogLevelsGetOptions
func (_e *Client_Expecter) GetLogLevels(ctx interface{}, opts interface{}) *Client_GetLogLevels_Call {
	return &Client_GetLogLevels_Call{Call: _e.mock.On("GetLogLevels", ctx, opts)}
}

func (_c *Client_GetLogLevels_Call) Run(run func(ctx context.Context, opts *arangodb.LogLevelsGetOptions)) *Client_GetLogLevels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*arangodb.LogLevelsGetOptions))
	})
	return _c
}

func (_c *Client_GetLogLevels_Call) Return(_a0 arangodb.LogLevels, _a1 error) *Client_GetLogLevels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetLogLevels_Call) RunAndReturn(run func(context.Context, *arangodb.LogLevelsGetOptions) (arangodb.LogLevels, error)) *Client_GetLogLevels_Call {
	_c.Call.Return(run)
	return _c
}

// Head provides a mock function with given fields: ctx, output, urlParts
func (_m *Client) Head(ctx context.Context, output interface{}, urlParts ...string) (connection.Response, error) {
	_va := make([]interface{}, len(urlParts))
	for _i := range urlParts {
		_va[_i] = urlParts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, output)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Head")
	}

	var r0 connection.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...string) (connection.Response, error)); ok {
		return rf(ctx, output, urlParts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...string) connection.Response); ok {
		r0 = rf(ctx, output, urlParts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(connection.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}, ...string) error); ok {
		r1 = rf(ctx, output, urlParts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Head_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Head'
type Client_Head_Call struct {
	*mock.Call
}

// Head is a helper method to define mock.On call
//   - ctx context.Context
//   - output interface{}
//   - urlParts ...string
func (_e *Client_Expecter) Head(ctx interface{}, output interface{}, urlParts ...interface{}) *Client_Head_Call {
	return &Client_Head_Call{Call: _e.mock.On("Head",
		append([]interface{}{ctx, output}, urlParts...)...)}
}

func (_c *Client_Head_Call) Run(run func(ctx context.Context, output interface{}, urlParts ...string)) *Client_Head_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Client_Head_Call) Return(_a0 connection.Response, _a1 error) *Client_Head_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Head_Call) RunAndReturn(run func(context.Context, interface{}, ...string) (connection.Response, error)) *Client_Head_Call {
	_c.Call.Return(run)
	return _c
}

// Health provides a mock function with given fields: ctx
func (_m *Client) Health(ctx context.Context) (arangodb.ClusterHealth, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Health")
	}

	var r0 arangodb.ClusterHealth
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (arangodb.ClusterHealth, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) arangodb.ClusterHealth); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(arangodb.ClusterHealth)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Health_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Health'
type Client_Health_Call struct {
	*mock.Call
}

// Health is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) Health(ctx interface{}) *Client_Health_Call {
	return &Client_Health_Call{Call: _e.mock.On("Health", ctx)}
}

func (_c *Client_Health_Call) Run(run func(ctx context.Context)) *Client_Health_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_Health_Call) Return(_a0 arangodb.ClusterHealth, _a1 error) *Client_Health_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Health_Call) RunAndReturn(run func(context.Context) (arangodb.ClusterHealth, error)) *Client_Health_Call {
	_c.Call.Return(run)
	return _c
}

// IsCleanedOut provides a mock function with given fields: ctx, serverID
func (_m *Client) IsCleanedOut(ctx context.Context, serverID arangodb.ServerID) (bool, error) {
	ret := _m.Called(ctx, serverID)

	if len(ret) == 0 {
		panic("no return value specified for IsCleanedOut")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.ServerID) (bool, error)); ok {
		return rf(ctx, serverID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.ServerID) bool); ok {
		r0 = rf(ctx, serverID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, arangodb.ServerID) error); ok {
		r1 = rf(ctx, serverID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_IsCleanedOut_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsCleanedOut'
type Client_IsCleanedOut_Call struct {
	*mock.Call
}

// IsCleanedOut is a helper method to define mock.On call
//   - ctx context.Context
//   - serverID arangodb.ServerID
func (_e *Client_Expecter) IsCleanedOut(ctx interface{}, serverID interface{}) *Client_IsCleanedOut_Call {
	return &Client_IsCleanedOut_Call{Call: _e.mock.On("IsCleanedOut", ctx, serverID)}
}

func (_c *Client_IsCleanedOut_Call) Run(run func(ctx context.Context, serverID arangodb.ServerID)) *Client_IsCleanedOut_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.ServerID))
	})
	return _c
}

func (_c *Client_IsCleanedOut_Call) Return(_a0 bool, _a1 error) *Client_IsCleanedOut_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_IsCleanedOut_Call) RunAndReturn(run func(context.Context, arangodb.ServerID) (bool, error)) *Client_IsCleanedOut_Call {
	_c.Call.Return(run)
	return _c
}

// MoveShard provides a mock function with given fields: ctx, col, shard, fromServer, toServer
func (_m *Client) MoveShard(ctx context.Context, col arangodb.Collection, shard arangodb.ShardID, fromServer arangodb.ServerID, toServer arangodb.ServerID) (string, error) {
	ret := _m.Called(ctx, col, shard, fromServer, toServer)

	if len(ret) == 0 {
		panic("no return value specified for MoveShard")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.Collection, arangodb.ShardID, arangodb.ServerID, arangodb.ServerID) (string, error)); ok {
		return rf(ctx, col, shard, fromServer, toServer)
	}
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.Collection, arangodb.ShardID, arangodb.ServerID, arangodb.ServerID) string); ok {
		r0 = rf(ctx, col, shard, fromServer, toServer)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, arangodb.Collection, arangodb.ShardID, arangodb.ServerID, arangodb.ServerID) error); ok {
		r1 = rf(ctx, col, shard, fromServer, toServer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_MoveShard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MoveShard'
type Client_MoveShard_Call struct {
	*mock.Call
}

// MoveShard is a helper method to define mock.On call
//   - ctx context.Context
//   - col arangodb.Collection
//   - shard arangodb.ShardID
//   - fromServer arangodb.ServerID
//   - toServer arangodb.ServerID
func (_e *Client_Expecter) MoveShard(ctx interface{}, col interface{}, shard interface{}, fromServer interface{}, toServer interface{}) *Client_MoveShard_Call {
	return &Client_MoveShard_Call{Call: _e.mock.On("MoveShard", ctx, col, shard, fromServer, toServer)}
}

func (_c *Client_MoveShard_Call) Run(run func(ctx context.Context, col arangodb.Collection, shard arangodb.ShardID, fromServer arangodb.ServerID, toServer arangodb.ServerID)) *Client_MoveShard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.Collection), args[2].(arangodb.ShardID), args[3].(arangodb.ServerID), args[4].(arangodb.ServerID))
	})
	return _c
}

func (_c *Client_MoveShard_Call) Return(_a0 string, _a1 error) *Client_MoveShard_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_MoveShard_Call) RunAndReturn(run func(context.Context, arangodb.Collection, arangodb.ShardID, arangodb.ServerID, arangodb.ServerID) (string, error)) *Client_MoveShard_Call {
	_c.Call.Return(run)
	return _c
}

// NumberOfServers provides a mock function with given fields: ctx
func (_m *Client) NumberOfServers(ctx context.Context) (arangodb.NumberOfServersResponse, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NumberOfServers")
	}

	var r0 arangodb.NumberOfServersResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (arangodb.NumberOfServersResponse, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) arangodb.NumberOfServersResponse); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(arangodb.NumberOfServersResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_NumberOfServers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumberOfServers'
type Client_NumberOfServers_Call struct {
	*mock.Call
}

// NumberOfServers is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) NumberOfServers(ctx interface{}) *Client_NumberOfServers_Call {
	return &Client_NumberOfServers_Call{Call: _e.mock.On("NumberOfServers", ctx)}
}

func (_c *Client_NumberOfServers_Call) Run(run func(ctx context.Context)) *Client_NumberOfServers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_NumberOfServers_Call) Return(_a0 arangodb.NumberOfServersResponse, _a1 error) *Client_NumberOfServers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_NumberOfServers_Call) RunAndReturn(run func(context.Context) (arangodb.NumberOfServersResponse, error)) *Client_NumberOfServers_Call {
	_c.Call.Return(run)
	return _c
}

// Patch provides a mock function with given fields: ctx, output, input, urlParts
func (_m *Client) Patch(ctx context.Context, output interface{}, input interface{}, urlParts ...string) (connection.Response, error) {
	_va := make([]interface{}, len(urlParts))
	for _i := range urlParts {
		_va[_i] = urlParts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, output, input)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Patch")
	}

	var r0 connection.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, interface{}, ...string) (connection.Response, error)); ok {
		return rf(ctx, output, input, urlParts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, interface{}, ...string) connection.Response); ok {
		r0 = rf(ctx, output, input, urlParts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(connection.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}, interface{}, ...string) error); ok {
		r1 = rf(ctx, output, input, urlParts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Patch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Patch'
type Client_Patch_Call struct {
	*mock.Call
}

// Patch is a helper method to define mock.On call
//   - ctx context.Context
//   - output interface{}
//   - input interface{}
//   - urlParts ...string
func (_e *Client_Expecter) Patch(ctx interface{}, output interface{}, input interface{}, urlParts ...interface{}) *Client_Patch_Call {
	return &Client_Patch_Call{Call: _e.mock.On("Patch",
		append([]interface{}{ctx, output, input}, urlParts...)...)}
}

func (_c *Client_Patch_Call) Run(run func(ctx context.Context, output interface{}, input interface{}, urlParts ...string)) *Client_Patch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), args[2].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Client_Patch_Call) Return(_a0 connection.Response, _a1 error) *Client_Patch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Patch_Call) RunAndReturn(run func(context.Context, interface{}, interface{}, ...string) (connection.Response, error)) *Client_Patch_Call {
	_c.Call.Return(run)
	return _c
}

// Post provides a mock function with given fields: ctx, output, input, urlParts
func (_m *Client) Post(ctx context.Context, output interface{}, input interface{}, urlParts ...string) (connection.Response, error) {
	_va := make([]interface{}, len(urlParts))
	for _i := range urlParts {
		_va[_i] = urlParts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, output, input)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Post")
	}

	var r0 connection.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, interface{}, ...string) (connection.Response, error)); ok {
		return rf(ctx, output, input, urlParts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, interface{}, ...string) connection.Response); ok {
		r0 = rf(ctx, output, input, urlParts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(connection.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}, interface{}, ...string) error); ok {
		r1 = rf(ctx, output, input, urlParts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Post_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Post'
type Client_Post_Call struct {
	*mock.Call
}

// Post is a helper method to define mock.On call
//   - ctx context.Context
//   - output interface{}
//   - input interface{}
//   - urlParts ...string
func (_e *Client_Expecter) Post(ctx interface{}, output interface{}, input interface{}, urlParts ...interface{}) *Client_Post_Call {
	return &Client_Post_Call{Call: _e.mock.On("Post",
		append([]interface{}{ctx, output, input}, urlParts...)...)}
}

func (_c *Client_Post_Call) Run(run func(ctx context.Context, output interface{}, input interface{}, urlParts ...string)) *Client_Post_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), args[2].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Client_Post_Call) Return(_a0 connection.Response, _a1 error) *Client_Post_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Post_Call) RunAndReturn(run func(context.Context, interface{}, interface{}, ...string) (connection.Response, error)) *Client_Post_Call {
	_c.Call.Return(run)
	return _c
}

// Put provides a mock function with given fields: ctx, output, input, urlParts
func (_m *Client) Put(ctx context.Context, output interface{}, input interface{}, urlParts ...string) (connection.Response, error) {
	_va := make([]interface{}, len(urlParts))
	for _i := range urlParts {
		_va[_i] = urlParts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, output, input)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Put")
	}

	var r0 connection.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, interface{}, ...string) (connection.Response, error)); ok {
		return rf(ctx, output, input, urlParts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, interface{}, ...string) connection.Response); ok {
		r0 = rf(ctx, output, input, urlParts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(connection.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}, interface{}, ...string) error); ok {
		r1 = rf(ctx, output, input, urlParts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Put_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Put'
type Client_Put_Call struct {
	*mock.Call
}

// Put is a helper method to define mock.On call
//   - ctx context.Context
//   - output interface{}
//   - input interface{}
//   - urlParts ...string
func (_e *Client_Expecter) Put(ctx interface{}, output interface{}, input interface{}, urlParts ...interface{}) *Client_Put_Call {
	return &Client_Put_Call{Call: _e.mock.On("Put",
		append([]interface{}{ctx, output, input}, urlParts...)...)}
}

func (_c *Client_Put_Call) Run(run func(ctx context.Context, output interface{}, input interface{}, urlParts ...string)) *Client_Put_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), args[2].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Client_Put_Call) Return(_a0 connection.Response, _a1 error) *Client_Put_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Put_Call) RunAndReturn(run func(context.Context, interface{}, interface{}, ...string) (connection.Response, error)) *Client_Put_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveServer provides a mock function with given fields: ctx, serverID
func (_m *Client) RemoveServer(ctx context.Context, serverID arangodb.ServerID) error {
	ret := _m.Called(ctx, serverID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveServer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.ServerID) error); ok {
		r0 = rf(ctx, serverID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_RemoveServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveServer'
type Client_RemoveServer_Call struct {
	*mock.Call
}

// RemoveServer is a helper method to define mock.On call
//   - ctx context.Context
//   - serverID arangodb.ServerID
func (_e *Client_Expecter) RemoveServer(ctx interface{}, serverID interface{}) *Client_RemoveServer_Call {
	return &Client_RemoveServer_Call{Call: _e.mock.On("RemoveServer", ctx, serverID)}
}

func (_c *Client_RemoveServer_Call) Run(run func(ctx context.Context, serverID arangodb.ServerID)) *Client_RemoveServer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.ServerID))
	})
	return _c
}

func (_c *Client_RemoveServer_Call) Return(_a0 error) *Client_RemoveServer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_RemoveServer_Call) RunAndReturn(run func(context.Context, arangodb.ServerID) error) *Client_RemoveServer_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveUser provides a mock function with given fields: ctx, name
func (_m *Client) RemoveUser(ctx context.Context, name string) error {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoveUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_RemoveUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveUser'
type Client_RemoveUser_Call struct {
	*mock.Call
}

// RemoveUser is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Client_Expecter) RemoveUser(ctx interface{}, name interface{}) *Client_RemoveUser_Call {
	return &Client_RemoveUser_Call{Call: _e.mock.On("RemoveUser", ctx, name)}
}

func (_c *Client_RemoveUser_Call) Run(run func(ctx context.Context, name string)) *Client_RemoveUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_RemoveUser_Call) Return(_a0 error) *Client_RemoveUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_RemoveUser_Call) RunAndReturn(run func(context.Context, string) error) *Client_RemoveUser_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceUser provides a mock function with given fields: ctx, name, options
func (_m *Client) ReplaceUser(ctx context.Context, name string, options *arangodb.UserOptions) (arangodb.User, error) {
	ret := _m.Called(ctx, name, options)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceUser")
	}

	var r0 arangodb.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.UserOptions) (arangodb.User, error)); ok {
		return rf(ctx, name, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.UserOptions) arangodb.User); ok {
		r0 = rf(ctx, name, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.UserOptions) error); ok {
		r1 = rf(ctx, name, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_ReplaceUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceUser'
type Client_ReplaceUser_Call struct {
	*mock.Call
}

// ReplaceUser is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - options *arangodb.UserOptions
func (_e *Client_Expecter) ReplaceUser(ctx interface{}, name interface{}, options interface{}) *Client_ReplaceUser_Call {
	return &Client_ReplaceUser_Call{Call: _e.mock.On("ReplaceUser", ctx, name, options)}
}

func (_c *Client_ReplaceUser_Call) Run(run func(ctx context.Context, name string, options *arangodb.UserOptions)) *Client_ReplaceUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.UserOptions))
	})
	return _c
}

func (_c *Client_ReplaceUser_Call) Return(_a0 arangodb.User, _a1 error) *Client_ReplaceUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_ReplaceUser_Call) RunAndReturn(run func(context.Context, string, *arangodb.UserOptions) (arangodb.User, error)) *Client_ReplaceUser_Call {
	_c.Call.Return(run)
	return _c
}

// ResignServer provides a mock function with given fields: ctx, serverID
func (_m *Client) ResignServer(ctx context.Context, serverID arangodb.ServerID) (string, error) {
	ret := _m.Called(ctx, serverID)

	if len(ret) == 0 {
		panic("no return value specified for ResignServer")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.ServerID) (string, error)); ok {
		return rf(ctx, serverID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.ServerID) string); ok {
		r0 = rf(ctx, serverID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, arangodb.ServerID) error); ok {
		r1 = rf(ctx, serverID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_ResignServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResignServer'
type Client_ResignServer_Call struct {
	*mock.Call
}

// ResignServer is a helper method to define mock.On call
//   - ctx context.Context
//   - serverID arangodb.ServerID
func (_e *Client_Expecter) ResignServer(ctx interface{}, serverID interface{}) *Client_ResignServer_Call {
	return &Client_ResignServer_Call{Call: _e.mock.On("ResignServer", ctx, serverID)}
}

func (_c *Client_ResignServer_Call) Run(run func(ctx context.Context, serverID arangodb.ServerID)) *Client_ResignServer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.ServerID))
	})
	return _c
}

func (_c *Client_ResignServer_Call) Return(_a0 string, _a1 error) *Client_ResignServer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_ResignServer_Call) RunAndReturn(run func(context.Context, arangodb.ServerID) (string, error)) *Client_ResignServer_Call {
	_c.Call.Return(run)
	return _c
}

// ServerID provides a mock function with given fields: ctx
func (_m *Client) ServerID(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ServerID")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_ServerID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServerID'
type Client_ServerID_Call struct {
	*mock.Call
}

// ServerID is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) ServerID(ctx interface{}) *Client_ServerID_Call {
	return &Client_ServerID_Call{Call: _e.mock.On("ServerID", ctx)}
}

func (_c *Client_ServerID_Call) Run(run func(ctx context.Context)) *Client_ServerID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_ServerID_Call) Return(_a0 string, _a1 error) *Client_ServerID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_ServerID_Call) RunAndReturn(run func(context.Context) (string, error)) *Client_ServerID_Call {
	_c.Call.Return(run)
	return _c
}

// ServerMode provides a mock function with given fields: ctx
func (_m *Client) ServerMode(ctx context.Context) (arangodb.ServerMode, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ServerMode")
	}

	var r0 arangodb.ServerMode
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (arangodb.ServerMode, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) arangodb.ServerMode); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(arangodb.ServerMode)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_ServerMode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServerMode'
type Client_ServerMode_Call struct {
	*mock.Call
}

// ServerMode is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) ServerMode(ctx interface{}) *Client_ServerMode_Call {
	return &Client_ServerMode_Call{Call: _e.mock.On("ServerMode", ctx)}
}

func (_c *Client_ServerMode_Call) Run(run func(ctx context.Context)) *Client_ServerMode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_ServerMode_Call) Return(_a0 arangodb.ServerMode, _a1 error) *Client_ServerMode_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_ServerMode_Call) RunAndReturn(run func(context.Context) (arangodb.ServerMode, error)) *Client_ServerMode_Call {
	_c.Call.Return(run)
	return _c
}

// ServerRole provides a mock function with given fields: ctx
func (_m *Client) ServerRole(ctx context.Context) (arangodb.ServerRole, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ServerRole")
	}

	var r0 arangodb.ServerRole
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (arangodb.ServerRole, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) arangodb.ServerRole); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(arangodb.ServerRole)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_ServerRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServerRole'
type Client_ServerRole_Call struct {
	*mock.Call
}

// ServerRole is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) ServerRole(ctx interface{}) *Client_ServerRole_Call {
	return &Client_ServerRole_Call{Call: _e.mock.On("ServerRole", ctx)}
}

func (_c *Client_ServerRole_Call) Run(run func(ctx context.Context)) *Client_ServerRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_ServerRole_Call) Return(_a0 arangodb.ServerRole, _a1 error) *Client_ServerRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_ServerRole_Call) RunAndReturn(run func(context.Context) (arangodb.ServerRole, error)) *Client_ServerRole_Call {
	_c.Call.Return(run)
	return _c
}

// SetLicense provides a mock function with given fields: ctx, license, force
func (_m *Client) SetLicense(ctx context.Context, license string, force bool) error {
	ret := _m.Called(ctx, license, force)

	if len(ret) == 0 {
		panic("no return value specified for SetLicense")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = rf(ctx, license, force)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_SetLicense_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLicense'
type Client_SetLicense_Call struct {
	*mock.Call
}

// SetLicense is a helper method to define mock.On call
//   - ctx context.Context
//   - license string
//   - force bool
func (_e *Client_Expecter) SetLicense(ctx interface{}, license interface{}, force interface{}) *Client_SetLicense_Call {
	return &Client_SetLicense_Call{Call: _e.mock.On("SetLicense", ctx, license, force)}
}

func (_c *Client_SetLicense_Call) Run(run func(ctx context.Context, license string, force bool)) *Client_SetLicense_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *Client_SetLicense_Call) Return(_a0 error) *Client_SetLicense_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_SetLicense_Call) RunAndReturn(run func(context.Context, string, bool) error) *Client_SetLicense_Call {
	_c.Call.Return(run)
	return _c
}

// SetLogLevels provides a mock function with given fields: ctx, logLevels, opts
func (_m *Client) SetLogLevels(ctx context.Context, logLevels arangodb.LogLevels, opts *arangodb.LogLevelsSetOptions) error {
	ret := _m.Called(ctx, logLevels, opts)

	if len(ret) == 0 {
		panic("no return value specified for SetLogLevels")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.LogLevels, *arangodb.LogLevelsSetOptions) error); ok {
		r0 = rf(ctx, logLevels, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_SetLogLevels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLogLevels'
type Client_SetLogLevels_Call struct {
	*mock.Call
}

// SetLogLevels is a helper method to define mock.On call
//   - ctx context.Context
//   - logLevels arangodb.LogLevels
//   - opts *arangodb.LogLevelsSetOptions
func (_e *Client_Expecter) SetLogLevels(ctx interface{}, logLevels interface{}, opts interface{}) *Client_SetLogLevels_Call {
	return &Client_SetLogLevels_Call{Call: _e.mock.On("SetLogLevels", ctx, logLevels, opts)}
}

func (_c *Client_SetLogLevels_Call) Run(run func(ctx context.Context, logLevels arangodb.LogLevels, opts *arangodb.LogLevelsSetOptions)) *Client_SetLogLevels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.LogLevels), args[2].(*arangodb.LogLevelsSetOptions))
	})
	return _c
}

func (_c *Client_SetLogLevels_Call) Return(_a0 error) *Client_SetLogLevels_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_SetLogLevels_Call) RunAndReturn(run func(context.Context, arangodb.LogLevels, *arangodb.LogLevelsSetOptions) error) *Client_SetLogLevels_Call {
	_c.Call.Return(run)
	return _c
}

// SetServerMode provides a mock function with given fields: ctx, mode
func (_m *Client) SetServerMode(ctx context.Context, mode arangodb.ServerMode) error {
	ret := _m.Called(ctx, mode)

	if len(ret) == 0 {
		panic("no return value specified for SetServerMode")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.ServerMode) error); ok {
		r0 = rf(ctx, mode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_SetServerMode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetServerMode'
type Client_SetServerMode_Call struct {
	*mock.Call
}

// SetServerMode is a helper method to define mock.On call
//   - ctx context.Context
//   - mode arangodb.ServerMode
func (_e *Client_Expecter) SetServerMode(ctx interface{}, mode interface{}) *Client_SetServerMode_Call {
	return &Client_SetServerMode_Call{Call: _e.mock.On("SetServerMode", ctx, mode)}
}

func (_c *Client_SetServerMode_Call) Run(run func(ctx context.Context, mode arangodb.ServerMode)) *Client_SetServerMode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.ServerMode))
	})
	return _c
}

func (_c *Client_SetServerMode_Call) Return(_a0 error) *Client_SetServerMode_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_SetServerMode_Call) RunAndReturn(run func(context.Context, arangodb.ServerMode) error) *Client_SetServerMode_Call {
	_c.Call.Return(run)
	return _c
}

// TransferMonitor provides a mock function with given fields: jobId, transferType
func (_m *Client) TransferMonitor(jobId string, transferType arangodb.TransferType) (arangodb.TransferMonitor, error) {
	ret := _m.Called(jobId, transferType)

	if len(ret) == 0 {
		panic("no return value specified for TransferMonitor")
	}

	var r0 arangodb.TransferMonitor
	var r1 error
	if rf, ok := ret.Get(0).(func(string, arangodb.TransferType) (arangodb.TransferMonitor, error)); ok {
		return rf(jobId, transferType)
	}
	if rf, ok := ret.Get(0).(func(string, arangodb.TransferType) arangodb.TransferMonitor); ok {
		r0 = rf(jobId, transferType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.TransferMonitor)
		}
	}

	if rf, ok := ret.Get(1).(func(string, arangodb.TransferType) error); ok {
		r1 = rf(jobId, transferType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_TransferMonitor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransferMonitor'
type Client_TransferMonitor_Call struct {
	*mock.Call
}

// TransferMonitor is a helper method to define mock.On call
//   - jobId string
//   - transferType arangodb.TransferType
func (_e *Client_Expecter) TransferMonitor(jobId interface{}, transferType interface{}) *Client_TransferMonitor_Call {
	return &Client_TransferMonitor_Call{Call: _e.mock.On("TransferMonitor", jobId, transferType)}
}

func (_c *Client_TransferMonitor_Call) Run(run func(jobId string, transferType arangodb.TransferType)) *Client_TransferMonitor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(arangodb.TransferType))
	})
	return _c
}

func (_c *Client_TransferMonitor_Call) Return(_a0 arangodb.TransferMonitor, _a1 error) *Client_TransferMonitor_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_TransferMonitor_Call) RunAndReturn(run func(string, arangodb.TransferType) (arangodb.TransferMonitor, error)) *Client_TransferMonitor_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: ctx, name, options
func (_m *Client) UpdateUser(ctx context.Context, name string, options *arangodb.UserOptions) (arangodb.User, error) {
	ret := _m.Called(ctx, name, options)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 arangodb.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.UserOptions) (arangodb.User, error)); ok {
		return rf(ctx, name, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.UserOptions) arangodb.User); ok {
		r0 = rf(ctx, name, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.UserOptions) error); ok {
		r1 = rf(ctx, name, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type Client_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - options *arangodb.UserOptions
func (_e *Client_Expecter) UpdateUser(ctx interface{}, name interface{}, options interface{}) *Client_UpdateUser_Call {
	return &Client_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, name, options)}
}

func (_c *Client_UpdateUser_Call) Run(run func(ctx context.Context, name string, options *arangodb.UserOptions)) *Client_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.UserOptions))
	})
	return _c
}

func (_c *Client_UpdateUser_Call) Return(_a0 arangodb.User, _a1 error) *Client_UpdateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_UpdateUser_Call) RunAndReturn(run func(context.Context, string, *arangodb.UserOptions) (arangodb.User, error)) *Client_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// User provides a mock function with given fields: ctx, name
func (_m *Client) User(ctx context.Context, name string) (arangodb.User, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for User")
	}

	var r0 arangodb.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (arangodb.User, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) arangodb.User); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_User_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'User'
type Client_User_Call struct {
	*mock.Call
}

// User is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Client_Expecter) User(ctx interface{}, name interface{}) *Client_User_Call {
	return &Client_User_Call{Call: _e.mock.On("User", ctx, name)}
}

func (_c *Client_User_Call) Run(run func(ctx context.Context, name string)) *Client_User_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_User_Call) Return(_a0 arangodb.User, _a1 error) *Client_User_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_User_Call) RunAndReturn(run func(context.Context, string) (arangodb.User, error)) *Client_User_Call {
	_c.Call.Return(run)
	return _c
}

// UserExists provides a mock function with given fields: ctx, name
func (_m *Client) UserExists(ctx context.Context, name string) (bool, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for UserExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_UserExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserExists'
type Client_UserExists_Call struct {
	*mock.Call
}

// UserExists is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Client_Expecter) UserExists(ctx interface{}, name interface{}) *Client_UserExists_Call {
	return &Client_UserExists_Call{Call: _e.mock.On("UserExists", ctx, name)}
}

func (_c *Client_UserExists_Call) Run(run func(ctx context.Context, name string)) *Client_UserExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_UserExists_Call) Return(_a0 bool, _a1 error) *Client_UserExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_UserExists_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *Client_UserExists_Call {
	_c.Call.Return(run)
	return _c
}

// Users provides a mock function with given fields: ctx
func (_m *Client) Users(ctx context.Context) ([]arangodb.User, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Users")
	}

	var r0 []arangodb.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]arangodb.User, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []arangodb.User); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]arangodb.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Users_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Users'
type Client_Users_Call struct {
	*mock.Call
}

// Users is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) Users(ctx interface{}) *Client_Users_Call {
	return &Client_Users_Call{Call: _e.mock.On("Users", ctx)}
}

func (_c *Client_Users_Call) Run(run func(ctx context.Context)) *Client_Users_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_Users_Call) Return(_a0 []arangodb.User, _a1 error) *Client_Users_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Users_Call) RunAndReturn(run func(context.Context) ([]arangodb.User, error)) *Client_Users_Call {
	_c.Call.Return(run)
	return _c
}

// Version provides a mock function with given fields: ctx
func (_m *Client) Version(ctx context.Context) (arangodb.VersionInfo, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Version")
	}

	var r0 arangodb.VersionInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (arangodb.VersionInfo, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) arangodb.VersionInfo); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(arangodb.VersionInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Version_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Version'
type Client_Version_Call struct {
	*mock.Call
}

// Version is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) Version(ctx interface{}) *Client_Version_Call {
	return &Client_Version_Call{Call: _e.mock.On("Version", ctx)}
}

func (_c *Client_Version_Call) Run(run func(ctx context.Context)) *Client_Version_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_Version_Call) Return(_a0 arangodb.VersionInfo, _a1 error) *Client_Version_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Version_Call) RunAndReturn(run func(context.Context) (arangodb.VersionInfo, error)) *Client_Version_Call {
	_c.Call.Return(run)
	return _c
}

// VersionWithOptions provides a mock function with given fields: ctx, opts
func (_m *Client) VersionWithOptions(ctx context.Context, opts *arangodb.GetVersionOptions) (arangodb.VersionInfo, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for VersionWithOptions")
	}

	var r0 arangodb.VersionInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *arangodb.GetVersionOptions) (arangodb.VersionInfo, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *arangodb.GetVersionOptions) arangodb.VersionInfo); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Get(0).(arangodb.VersionInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *arangodb.GetVersionOptions) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_VersionWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VersionWithOptions'
type Client_VersionWithOptions_Call struct {
	*mock.Call
}

// VersionWithOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *arangodb.GetVersionOptions
func (_e *Client_Expecter) VersionWithOptions(ctx interface{}, opts interface{}) *Client_VersionWithOptions_Call {
	return &Client_VersionWithOptions_Call{Call: _e.mock.On("VersionWithOptions", ctx, opts)}
}

func (_c *Client_VersionWithOptions_Call) Run(run func(ctx context.Context, opts *arangodb.GetVersionOptions)) *Client_VersionWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*arangodb.GetVersionOptions))
	})
	return _c
}

func (_c *Client_VersionWithOptions_Call) Return(_a0 arangodb.VersionInfo, _a1 error) *Client_VersionWithOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_VersionWithOptions_Call) RunAndReturn(run func(context.Context, *arangodb.GetVersionOptions) (arangodb.VersionInfo, error)) *Client_VersionWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
