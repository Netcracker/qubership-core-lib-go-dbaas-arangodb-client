// Code generated by mockery v2.40.3. DO NOT EDIT.

package mocks

import (
	context "context"

	arangodb "github.com/arangodb/go-driver/v2/arangodb"

	mock "github.com/stretchr/testify/mock"
)

// Database is an autogenerated mock type for the Database type
type Database struct {
	mock.Mock
}

type Database_Expecter struct {
	mock *mock.Mock
}

func (_m *Database) EXPECT() *Database_Expecter {
	return &Database_Expecter{mock: &_m.Mock}
}

// Analyzer provides a mock function with given fields: ctx, name
func (_m *Database) Analyzer(ctx context.Context, name string) (arangodb.Analyzer, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for Analyzer")
	}

	var r0 arangodb.Analyzer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (arangodb.Analyzer, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) arangodb.Analyzer); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Analyzer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_Analyzer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Analyzer'
type Database_Analyzer_Call struct {
	*mock.Call
}

// Analyzer is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Database_Expecter) Analyzer(ctx interface{}, name interface{}) *Database_Analyzer_Call {
	return &Database_Analyzer_Call{Call: _e.mock.On("Analyzer", ctx, name)}
}

func (_c *Database_Analyzer_Call) Run(run func(ctx context.Context, name string)) *Database_Analyzer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Database_Analyzer_Call) Return(_a0 arangodb.Analyzer, _a1 error) *Database_Analyzer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_Analyzer_Call) RunAndReturn(run func(context.Context, string) (arangodb.Analyzer, error)) *Database_Analyzer_Call {
	_c.Call.Return(run)
	return _c
}

// Analyzers provides a mock function with given fields: ctx
func (_m *Database) Analyzers(ctx context.Context) (arangodb.AnalyzersResponseReader, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Analyzers")
	}

	var r0 arangodb.AnalyzersResponseReader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (arangodb.AnalyzersResponseReader, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) arangodb.AnalyzersResponseReader); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.AnalyzersResponseReader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_Analyzers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Analyzers'
type Database_Analyzers_Call struct {
	*mock.Call
}

// Analyzers is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) Analyzers(ctx interface{}) *Database_Analyzers_Call {
	return &Database_Analyzers_Call{Call: _e.mock.On("Analyzers", ctx)}
}

func (_c *Database_Analyzers_Call) Run(run func(ctx context.Context)) *Database_Analyzers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Database_Analyzers_Call) Return(_a0 arangodb.AnalyzersResponseReader, _a1 error) *Database_Analyzers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_Analyzers_Call) RunAndReturn(run func(context.Context) (arangodb.AnalyzersResponseReader, error)) *Database_Analyzers_Call {
	_c.Call.Return(run)
	return _c
}

// BeginTransaction provides a mock function with given fields: ctx, cols, opts
func (_m *Database) BeginTransaction(ctx context.Context, cols arangodb.TransactionCollections, opts *arangodb.BeginTransactionOptions) (arangodb.Transaction, error) {
	ret := _m.Called(ctx, cols, opts)

	if len(ret) == 0 {
		panic("no return value specified for BeginTransaction")
	}

	var r0 arangodb.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.TransactionCollections, *arangodb.BeginTransactionOptions) (arangodb.Transaction, error)); ok {
		return rf(ctx, cols, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.TransactionCollections, *arangodb.BeginTransactionOptions) arangodb.Transaction); ok {
		r0 = rf(ctx, cols, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, arangodb.TransactionCollections, *arangodb.BeginTransactionOptions) error); ok {
		r1 = rf(ctx, cols, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_BeginTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BeginTransaction'
type Database_BeginTransaction_Call struct {
	*mock.Call
}

// BeginTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - cols arangodb.TransactionCollections
//   - opts *arangodb.BeginTransactionOptions
func (_e *Database_Expecter) BeginTransaction(ctx interface{}, cols interface{}, opts interface{}) *Database_BeginTransaction_Call {
	return &Database_BeginTransaction_Call{Call: _e.mock.On("BeginTransaction", ctx, cols, opts)}
}

func (_c *Database_BeginTransaction_Call) Run(run func(ctx context.Context, cols arangodb.TransactionCollections, opts *arangodb.BeginTransactionOptions)) *Database_BeginTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.TransactionCollections), args[2].(*arangodb.BeginTransactionOptions))
	})
	return _c
}

func (_c *Database_BeginTransaction_Call) Return(_a0 arangodb.Transaction, _a1 error) *Database_BeginTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_BeginTransaction_Call) RunAndReturn(run func(context.Context, arangodb.TransactionCollections, *arangodb.BeginTransactionOptions) (arangodb.Transaction, error)) *Database_BeginTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// Collection provides a mock function with given fields: ctx, name
func (_m *Database) Collection(ctx context.Context, name string) (arangodb.Collection, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for Collection")
	}

	var r0 arangodb.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (arangodb.Collection, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) arangodb.Collection); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_Collection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Collection'
type Database_Collection_Call struct {
	*mock.Call
}

// Collection is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Database_Expecter) Collection(ctx interface{}, name interface{}) *Database_Collection_Call {
	return &Database_Collection_Call{Call: _e.mock.On("Collection", ctx, name)}
}

func (_c *Database_Collection_Call) Run(run func(ctx context.Context, name string)) *Database_Collection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Database_Collection_Call) Return(_a0 arangodb.Collection, _a1 error) *Database_Collection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_Collection_Call) RunAndReturn(run func(context.Context, string) (arangodb.Collection, error)) *Database_Collection_Call {
	_c.Call.Return(run)
	return _c
}

// CollectionExists provides a mock function with given fields: ctx, name
func (_m *Database) CollectionExists(ctx context.Context, name string) (bool, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for CollectionExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_CollectionExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CollectionExists'
type Database_CollectionExists_Call struct {
	*mock.Call
}

// CollectionExists is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Database_Expecter) CollectionExists(ctx interface{}, name interface{}) *Database_CollectionExists_Call {
	return &Database_CollectionExists_Call{Call: _e.mock.On("CollectionExists", ctx, name)}
}

func (_c *Database_CollectionExists_Call) Run(run func(ctx context.Context, name string)) *Database_CollectionExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Database_CollectionExists_Call) Return(_a0 bool, _a1 error) *Database_CollectionExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_CollectionExists_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *Database_CollectionExists_Call {
	_c.Call.Return(run)
	return _c
}

// Collections provides a mock function with given fields: ctx
func (_m *Database) Collections(ctx context.Context) ([]arangodb.Collection, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Collections")
	}

	var r0 []arangodb.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]arangodb.Collection, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []arangodb.Collection); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]arangodb.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_Collections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Collections'
type Database_Collections_Call struct {
	*mock.Call
}

// Collections is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) Collections(ctx interface{}) *Database_Collections_Call {
	return &Database_Collections_Call{Call: _e.mock.On("Collections", ctx)}
}

func (_c *Database_Collections_Call) Run(run func(ctx context.Context)) *Database_Collections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Database_Collections_Call) Return(_a0 []arangodb.Collection, _a1 error) *Database_Collections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_Collections_Call) RunAndReturn(run func(context.Context) ([]arangodb.Collection, error)) *Database_Collections_Call {
	_c.Call.Return(run)
	return _c
}

// CreateArangoSearchAliasView provides a mock function with given fields: ctx, name, options
func (_m *Database) CreateArangoSearchAliasView(ctx context.Context, name string, options *arangodb.ArangoSearchAliasViewProperties) (arangodb.ArangoSearchViewAlias, error) {
	ret := _m.Called(ctx, name, options)

	if len(ret) == 0 {
		panic("no return value specified for CreateArangoSearchAliasView")
	}

	var r0 arangodb.ArangoSearchViewAlias
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.ArangoSearchAliasViewProperties) (arangodb.ArangoSearchViewAlias, error)); ok {
		return rf(ctx, name, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.ArangoSearchAliasViewProperties) arangodb.ArangoSearchViewAlias); ok {
		r0 = rf(ctx, name, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.ArangoSearchViewAlias)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.ArangoSearchAliasViewProperties) error); ok {
		r1 = rf(ctx, name, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_CreateArangoSearchAliasView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateArangoSearchAliasView'
type Database_CreateArangoSearchAliasView_Call struct {
	*mock.Call
}

// CreateArangoSearchAliasView is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - options *arangodb.ArangoSearchAliasViewProperties
func (_e *Database_Expecter) CreateArangoSearchAliasView(ctx interface{}, name interface{}, options interface{}) *Database_CreateArangoSearchAliasView_Call {
	return &Database_CreateArangoSearchAliasView_Call{Call: _e.mock.On("CreateArangoSearchAliasView", ctx, name, options)}
}

func (_c *Database_CreateArangoSearchAliasView_Call) Run(run func(ctx context.Context, name string, options *arangodb.ArangoSearchAliasViewProperties)) *Database_CreateArangoSearchAliasView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.ArangoSearchAliasViewProperties))
	})
	return _c
}

func (_c *Database_CreateArangoSearchAliasView_Call) Return(_a0 arangodb.ArangoSearchViewAlias, _a1 error) *Database_CreateArangoSearchAliasView_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_CreateArangoSearchAliasView_Call) RunAndReturn(run func(context.Context, string, *arangodb.ArangoSearchAliasViewProperties) (arangodb.ArangoSearchViewAlias, error)) *Database_CreateArangoSearchAliasView_Call {
	_c.Call.Return(run)
	return _c
}

// CreateArangoSearchView provides a mock function with given fields: ctx, name, options
func (_m *Database) CreateArangoSearchView(ctx context.Context, name string, options *arangodb.ArangoSearchViewProperties) (arangodb.ArangoSearchView, error) {
	ret := _m.Called(ctx, name, options)

	if len(ret) == 0 {
		panic("no return value specified for CreateArangoSearchView")
	}

	var r0 arangodb.ArangoSearchView
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.ArangoSearchViewProperties) (arangodb.ArangoSearchView, error)); ok {
		return rf(ctx, name, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.ArangoSearchViewProperties) arangodb.ArangoSearchView); ok {
		r0 = rf(ctx, name, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.ArangoSearchView)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.ArangoSearchViewProperties) error); ok {
		r1 = rf(ctx, name, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_CreateArangoSearchView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateArangoSearchView'
type Database_CreateArangoSearchView_Call struct {
	*mock.Call
}

// CreateArangoSearchView is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - options *arangodb.ArangoSearchViewProperties
func (_e *Database_Expecter) CreateArangoSearchView(ctx interface{}, name interface{}, options interface{}) *Database_CreateArangoSearchView_Call {
	return &Database_CreateArangoSearchView_Call{Call: _e.mock.On("CreateArangoSearchView", ctx, name, options)}
}

func (_c *Database_CreateArangoSearchView_Call) Run(run func(ctx context.Context, name string, options *arangodb.ArangoSearchViewProperties)) *Database_CreateArangoSearchView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.ArangoSearchViewProperties))
	})
	return _c
}

func (_c *Database_CreateArangoSearchView_Call) Return(_a0 arangodb.ArangoSearchView, _a1 error) *Database_CreateArangoSearchView_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_CreateArangoSearchView_Call) RunAndReturn(run func(context.Context, string, *arangodb.ArangoSearchViewProperties) (arangodb.ArangoSearchView, error)) *Database_CreateArangoSearchView_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCollection provides a mock function with given fields: ctx, name, props
func (_m *Database) CreateCollection(ctx context.Context, name string, props *arangodb.CreateCollectionProperties) (arangodb.Collection, error) {
	ret := _m.Called(ctx, name, props)

	if len(ret) == 0 {
		panic("no return value specified for CreateCollection")
	}

	var r0 arangodb.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.CreateCollectionProperties) (arangodb.Collection, error)); ok {
		return rf(ctx, name, props)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.CreateCollectionProperties) arangodb.Collection); ok {
		r0 = rf(ctx, name, props)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.CreateCollectionProperties) error); ok {
		r1 = rf(ctx, name, props)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_CreateCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCollection'
type Database_CreateCollection_Call struct {
	*mock.Call
}

// CreateCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - props *arangodb.CreateCollectionProperties
func (_e *Database_Expecter) CreateCollection(ctx interface{}, name interface{}, props interface{}) *Database_CreateCollection_Call {
	return &Database_CreateCollection_Call{Call: _e.mock.On("CreateCollection", ctx, name, props)}
}

func (_c *Database_CreateCollection_Call) Run(run func(ctx context.Context, name string, props *arangodb.CreateCollectionProperties)) *Database_CreateCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.CreateCollectionProperties))
	})
	return _c
}

func (_c *Database_CreateCollection_Call) Return(_a0 arangodb.Collection, _a1 error) *Database_CreateCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_CreateCollection_Call) RunAndReturn(run func(context.Context, string, *arangodb.CreateCollectionProperties) (arangodb.Collection, error)) *Database_CreateCollection_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCollectionWithOptions provides a mock function with given fields: ctx, name, props, options
func (_m *Database) CreateCollectionWithOptions(ctx context.Context, name string, props *arangodb.CreateCollectionProperties, options *arangodb.CreateCollectionOptions) (arangodb.Collection, error) {
	ret := _m.Called(ctx, name, props, options)

	if len(ret) == 0 {
		panic("no return value specified for CreateCollectionWithOptions")
	}

	var r0 arangodb.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.CreateCollectionProperties, *arangodb.CreateCollectionOptions) (arangodb.Collection, error)); ok {
		return rf(ctx, name, props, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.CreateCollectionProperties, *arangodb.CreateCollectionOptions) arangodb.Collection); ok {
		r0 = rf(ctx, name, props, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.CreateCollectionProperties, *arangodb.CreateCollectionOptions) error); ok {
		r1 = rf(ctx, name, props, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_CreateCollectionWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCollectionWithOptions'
type Database_CreateCollectionWithOptions_Call struct {
	*mock.Call
}

// CreateCollectionWithOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - props *arangodb.CreateCollectionProperties
//   - options *arangodb.CreateCollectionOptions
func (_e *Database_Expecter) CreateCollectionWithOptions(ctx interface{}, name interface{}, props interface{}, options interface{}) *Database_CreateCollectionWithOptions_Call {
	return &Database_CreateCollectionWithOptions_Call{Call: _e.mock.On("CreateCollectionWithOptions", ctx, name, props, options)}
}

func (_c *Database_CreateCollectionWithOptions_Call) Run(run func(ctx context.Context, name string, props *arangodb.CreateCollectionProperties, options *arangodb.CreateCollectionOptions)) *Database_CreateCollectionWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.CreateCollectionProperties), args[3].(*arangodb.CreateCollectionOptions))
	})
	return _c
}

func (_c *Database_CreateCollectionWithOptions_Call) Return(_a0 arangodb.Collection, _a1 error) *Database_CreateCollectionWithOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_CreateCollectionWithOptions_Call) RunAndReturn(run func(context.Context, string, *arangodb.CreateCollectionProperties, *arangodb.CreateCollectionOptions) (arangodb.Collection, error)) *Database_CreateCollectionWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// CreateGraph provides a mock function with given fields: ctx, name, graph, options
func (_m *Database) CreateGraph(ctx context.Context, name string, graph *arangodb.GraphDefinition, options *arangodb.CreateGraphOptions) (arangodb.Graph, error) {
	ret := _m.Called(ctx, name, graph, options)

	if len(ret) == 0 {
		panic("no return value specified for CreateGraph")
	}

	var r0 arangodb.Graph
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.GraphDefinition, *arangodb.CreateGraphOptions) (arangodb.Graph, error)); ok {
		return rf(ctx, name, graph, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.GraphDefinition, *arangodb.CreateGraphOptions) arangodb.Graph); ok {
		r0 = rf(ctx, name, graph, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Graph)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.GraphDefinition, *arangodb.CreateGraphOptions) error); ok {
		r1 = rf(ctx, name, graph, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_CreateGraph_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateGraph'
type Database_CreateGraph_Call struct {
	*mock.Call
}

// CreateGraph is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - graph *arangodb.GraphDefinition
//   - options *arangodb.CreateGraphOptions
func (_e *Database_Expecter) CreateGraph(ctx interface{}, name interface{}, graph interface{}, options interface{}) *Database_CreateGraph_Call {
	return &Database_CreateGraph_Call{Call: _e.mock.On("CreateGraph", ctx, name, graph, options)}
}

func (_c *Database_CreateGraph_Call) Run(run func(ctx context.Context, name string, graph *arangodb.GraphDefinition, options *arangodb.CreateGraphOptions)) *Database_CreateGraph_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.GraphDefinition), args[3].(*arangodb.CreateGraphOptions))
	})
	return _c
}

func (_c *Database_CreateGraph_Call) Return(_a0 arangodb.Graph, _a1 error) *Database_CreateGraph_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_CreateGraph_Call) RunAndReturn(run func(context.Context, string, *arangodb.GraphDefinition, *arangodb.CreateGraphOptions) (arangodb.Graph, error)) *Database_CreateGraph_Call {
	_c.Call.Return(run)
	return _c
}

// EnsureAnalyzer provides a mock function with given fields: ctx, analyzer
func (_m *Database) EnsureAnalyzer(ctx context.Context, analyzer *arangodb.AnalyzerDefinition) (bool, arangodb.Analyzer, error) {
	ret := _m.Called(ctx, analyzer)

	if len(ret) == 0 {
		panic("no return value specified for EnsureAnalyzer")
	}

	var r0 bool
	var r1 arangodb.Analyzer
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *arangodb.AnalyzerDefinition) (bool, arangodb.Analyzer, error)); ok {
		return rf(ctx, analyzer)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *arangodb.AnalyzerDefinition) bool); ok {
		r0 = rf(ctx, analyzer)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *arangodb.AnalyzerDefinition) arangodb.Analyzer); ok {
		r1 = rf(ctx, analyzer)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(arangodb.Analyzer)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *arangodb.AnalyzerDefinition) error); ok {
		r2 = rf(ctx, analyzer)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Database_EnsureAnalyzer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureAnalyzer'
type Database_EnsureAnalyzer_Call struct {
	*mock.Call
}

// EnsureAnalyzer is a helper method to define mock.On call
//   - ctx context.Context
//   - analyzer *arangodb.AnalyzerDefinition
func (_e *Database_Expecter) EnsureAnalyzer(ctx interface{}, analyzer interface{}) *Database_EnsureAnalyzer_Call {
	return &Database_EnsureAnalyzer_Call{Call: _e.mock.On("EnsureAnalyzer", ctx, analyzer)}
}

func (_c *Database_EnsureAnalyzer_Call) Run(run func(ctx context.Context, analyzer *arangodb.AnalyzerDefinition)) *Database_EnsureAnalyzer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*arangodb.AnalyzerDefinition))
	})
	return _c
}

func (_c *Database_EnsureAnalyzer_Call) Return(_a0 bool, _a1 arangodb.Analyzer, _a2 error) *Database_EnsureAnalyzer_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Database_EnsureAnalyzer_Call) RunAndReturn(run func(context.Context, *arangodb.AnalyzerDefinition) (bool, arangodb.Analyzer, error)) *Database_EnsureAnalyzer_Call {
	_c.Call.Return(run)
	return _c
}

// ExplainQuery provides a mock function with given fields: ctx, query, bindVars, opts
func (_m *Database) ExplainQuery(ctx context.Context, query string, bindVars map[string]interface{}, opts *arangodb.ExplainQueryOptions) (arangodb.ExplainQueryResult, error) {
	ret := _m.Called(ctx, query, bindVars, opts)

	if len(ret) == 0 {
		panic("no return value specified for ExplainQuery")
	}

	var r0 arangodb.ExplainQueryResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, *arangodb.ExplainQueryOptions) (arangodb.ExplainQueryResult, error)); ok {
		return rf(ctx, query, bindVars, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]interface{}, *arangodb.ExplainQueryOptions) arangodb.ExplainQueryResult); ok {
		r0 = rf(ctx, query, bindVars, opts)
	} else {
		r0 = ret.Get(0).(arangodb.ExplainQueryResult)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]interface{}, *arangodb.ExplainQueryOptions) error); ok {
		r1 = rf(ctx, query, bindVars, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_ExplainQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExplainQuery'
type Database_ExplainQuery_Call struct {
	*mock.Call
}

// ExplainQuery is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - bindVars map[string]interface{}
//   - opts *arangodb.ExplainQueryOptions
func (_e *Database_Expecter) ExplainQuery(ctx interface{}, query interface{}, bindVars interface{}, opts interface{}) *Database_ExplainQuery_Call {
	return &Database_ExplainQuery_Call{Call: _e.mock.On("ExplainQuery", ctx, query, bindVars, opts)}
}

func (_c *Database_ExplainQuery_Call) Run(run func(ctx context.Context, query string, bindVars map[string]interface{}, opts *arangodb.ExplainQueryOptions)) *Database_ExplainQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]interface{}), args[3].(*arangodb.ExplainQueryOptions))
	})
	return _c
}

func (_c *Database_ExplainQuery_Call) Return(_a0 arangodb.ExplainQueryResult, _a1 error) *Database_ExplainQuery_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_ExplainQuery_Call) RunAndReturn(run func(context.Context, string, map[string]interface{}, *arangodb.ExplainQueryOptions) (arangodb.ExplainQueryResult, error)) *Database_ExplainQuery_Call {
	_c.Call.Return(run)
	return _c
}

// GetCollection provides a mock function with given fields: ctx, name, options
func (_m *Database) GetCollection(ctx context.Context, name string, options *arangodb.GetCollectionOptions) (arangodb.Collection, error) {
	ret := _m.Called(ctx, name, options)

	if len(ret) == 0 {
		panic("no return value specified for GetCollection")
	}

	var r0 arangodb.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.GetCollectionOptions) (arangodb.Collection, error)); ok {
		return rf(ctx, name, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.GetCollectionOptions) arangodb.Collection); ok {
		r0 = rf(ctx, name, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.GetCollectionOptions) error); ok {
		r1 = rf(ctx, name, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_GetCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCollection'
type Database_GetCollection_Call struct {
	*mock.Call
}

// GetCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - options *arangodb.GetCollectionOptions
func (_e *Database_Expecter) GetCollection(ctx interface{}, name interface{}, options interface{}) *Database_GetCollection_Call {
	return &Database_GetCollection_Call{Call: _e.mock.On("GetCollection", ctx, name, options)}
}

func (_c *Database_GetCollection_Call) Run(run func(ctx context.Context, name string, options *arangodb.GetCollectionOptions)) *Database_GetCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.GetCollectionOptions))
	})
	return _c
}

func (_c *Database_GetCollection_Call) Return(_a0 arangodb.Collection, _a1 error) *Database_GetCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_GetCollection_Call) RunAndReturn(run func(context.Context, string, *arangodb.GetCollectionOptions) (arangodb.Collection, error)) *Database_GetCollection_Call {
	_c.Call.Return(run)
	return _c
}

// GetEdges provides a mock function with given fields: ctx, name, vertex, options
func (_m *Database) GetEdges(ctx context.Context, name string, vertex string, options *arangodb.GetEdgesOptions) ([]arangodb.EdgeDetails, error) {
	ret := _m.Called(ctx, name, vertex, options)

	if len(ret) == 0 {
		panic("no return value specified for GetEdges")
	}

	var r0 []arangodb.EdgeDetails
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *arangodb.GetEdgesOptions) ([]arangodb.EdgeDetails, error)); ok {
		return rf(ctx, name, vertex, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *arangodb.GetEdgesOptions) []arangodb.EdgeDetails); ok {
		r0 = rf(ctx, name, vertex, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]arangodb.EdgeDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *arangodb.GetEdgesOptions) error); ok {
		r1 = rf(ctx, name, vertex, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_GetEdges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEdges'
type Database_GetEdges_Call struct {
	*mock.Call
}

// GetEdges is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - vertex string
//   - options *arangodb.GetEdgesOptions
func (_e *Database_Expecter) GetEdges(ctx interface{}, name interface{}, vertex interface{}, options interface{}) *Database_GetEdges_Call {
	return &Database_GetEdges_Call{Call: _e.mock.On("GetEdges", ctx, name, vertex, options)}
}

func (_c *Database_GetEdges_Call) Run(run func(ctx context.Context, name string, vertex string, options *arangodb.GetEdgesOptions)) *Database_GetEdges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*arangodb.GetEdgesOptions))
	})
	return _c
}

func (_c *Database_GetEdges_Call) Return(_a0 []arangodb.EdgeDetails, _a1 error) *Database_GetEdges_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_GetEdges_Call) RunAndReturn(run func(context.Context, string, string, *arangodb.GetEdgesOptions) ([]arangodb.EdgeDetails, error)) *Database_GetEdges_Call {
	_c.Call.Return(run)
	return _c
}

// Graph provides a mock function with given fields: ctx, name, options
func (_m *Database) Graph(ctx context.Context, name string, options *arangodb.GetGraphOptions) (arangodb.Graph, error) {
	ret := _m.Called(ctx, name, options)

	if len(ret) == 0 {
		panic("no return value specified for Graph")
	}

	var r0 arangodb.Graph
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.GetGraphOptions) (arangodb.Graph, error)); ok {
		return rf(ctx, name, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.GetGraphOptions) arangodb.Graph); ok {
		r0 = rf(ctx, name, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Graph)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.GetGraphOptions) error); ok {
		r1 = rf(ctx, name, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_Graph_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Graph'
type Database_Graph_Call struct {
	*mock.Call
}

// Graph is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - options *arangodb.GetGraphOptions
func (_e *Database_Expecter) Graph(ctx interface{}, name interface{}, options interface{}) *Database_Graph_Call {
	return &Database_Graph_Call{Call: _e.mock.On("Graph", ctx, name, options)}
}

func (_c *Database_Graph_Call) Run(run func(ctx context.Context, name string, options *arangodb.GetGraphOptions)) *Database_Graph_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.GetGraphOptions))
	})
	return _c
}

func (_c *Database_Graph_Call) Return(_a0 arangodb.Graph, _a1 error) *Database_Graph_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_Graph_Call) RunAndReturn(run func(context.Context, string, *arangodb.GetGraphOptions) (arangodb.Graph, error)) *Database_Graph_Call {
	_c.Call.Return(run)
	return _c
}

// GraphExists provides a mock function with given fields: ctx, name
func (_m *Database) GraphExists(ctx context.Context, name string) (bool, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GraphExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_GraphExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GraphExists'
type Database_GraphExists_Call struct {
	*mock.Call
}

// GraphExists is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Database_Expecter) GraphExists(ctx interface{}, name interface{}) *Database_GraphExists_Call {
	return &Database_GraphExists_Call{Call: _e.mock.On("GraphExists", ctx, name)}
}

func (_c *Database_GraphExists_Call) Run(run func(ctx context.Context, name string)) *Database_GraphExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Database_GraphExists_Call) Return(_a0 bool, _a1 error) *Database_GraphExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_GraphExists_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *Database_GraphExists_Call {
	_c.Call.Return(run)
	return _c
}

// Graphs provides a mock function with given fields: ctx
func (_m *Database) Graphs(ctx context.Context) (arangodb.GraphsResponseReader, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Graphs")
	}

	var r0 arangodb.GraphsResponseReader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (arangodb.GraphsResponseReader, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) arangodb.GraphsResponseReader); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.GraphsResponseReader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_Graphs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Graphs'
type Database_Graphs_Call struct {
	*mock.Call
}

// Graphs is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) Graphs(ctx interface{}) *Database_Graphs_Call {
	return &Database_Graphs_Call{Call: _e.mock.On("Graphs", ctx)}
}

func (_c *Database_Graphs_Call) Run(run func(ctx context.Context)) *Database_Graphs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Database_Graphs_Call) Return(_a0 arangodb.GraphsResponseReader, _a1 error) *Database_Graphs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_Graphs_Call) RunAndReturn(run func(context.Context) (arangodb.GraphsResponseReader, error)) *Database_Graphs_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function with given fields: ctx
func (_m *Database) Info(ctx context.Context) (arangodb.DatabaseInfo, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 arangodb.DatabaseInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (arangodb.DatabaseInfo, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) arangodb.DatabaseInfo); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(arangodb.DatabaseInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type Database_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) Info(ctx interface{}) *Database_Info_Call {
	return &Database_Info_Call{Call: _e.mock.On("Info", ctx)}
}

func (_c *Database_Info_Call) Run(run func(ctx context.Context)) *Database_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Database_Info_Call) Return(_a0 arangodb.DatabaseInfo, _a1 error) *Database_Info_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_Info_Call) RunAndReturn(run func(context.Context) (arangodb.DatabaseInfo, error)) *Database_Info_Call {
	_c.Call.Return(run)
	return _c
}

// ListTransactions provides a mock function with given fields: ctx
func (_m *Database) ListTransactions(ctx context.Context) ([]arangodb.Transaction, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListTransactions")
	}

	var r0 []arangodb.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]arangodb.Transaction, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []arangodb.Transaction); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]arangodb.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_ListTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTransactions'
type Database_ListTransactions_Call struct {
	*mock.Call
}

// ListTransactions is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) ListTransactions(ctx interface{}) *Database_ListTransactions_Call {
	return &Database_ListTransactions_Call{Call: _e.mock.On("ListTransactions", ctx)}
}

func (_c *Database_ListTransactions_Call) Run(run func(ctx context.Context)) *Database_ListTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Database_ListTransactions_Call) Return(_a0 []arangodb.Transaction, _a1 error) *Database_ListTransactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_ListTransactions_Call) RunAndReturn(run func(context.Context) ([]arangodb.Transaction, error)) *Database_ListTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// ListTransactionsWithStatuses provides a mock function with given fields: ctx, statuses
func (_m *Database) ListTransactionsWithStatuses(ctx context.Context, statuses ...arangodb.TransactionStatus) ([]arangodb.Transaction, error) {
	_va := make([]interface{}, len(statuses))
	for _i := range statuses {
		_va[_i] = statuses[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTransactionsWithStatuses")
	}

	var r0 []arangodb.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...arangodb.TransactionStatus) ([]arangodb.Transaction, error)); ok {
		return rf(ctx, statuses...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...arangodb.TransactionStatus) []arangodb.Transaction); ok {
		r0 = rf(ctx, statuses...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]arangodb.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...arangodb.TransactionStatus) error); ok {
		r1 = rf(ctx, statuses...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_ListTransactionsWithStatuses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTransactionsWithStatuses'
type Database_ListTransactionsWithStatuses_Call struct {
	*mock.Call
}

// ListTransactionsWithStatuses is a helper method to define mock.On call
//   - ctx context.Context
//   - statuses ...arangodb.TransactionStatus
func (_e *Database_Expecter) ListTransactionsWithStatuses(ctx interface{}, statuses ...interface{}) *Database_ListTransactionsWithStatuses_Call {
	return &Database_ListTransactionsWithStatuses_Call{Call: _e.mock.On("ListTransactionsWithStatuses",
		append([]interface{}{ctx}, statuses...)...)}
}

func (_c *Database_ListTransactionsWithStatuses_Call) Run(run func(ctx context.Context, statuses ...arangodb.TransactionStatus)) *Database_ListTransactionsWithStatuses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]arangodb.TransactionStatus, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(arangodb.TransactionStatus)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *Database_ListTransactionsWithStatuses_Call) Return(_a0 []arangodb.Transaction, _a1 error) *Database_ListTransactionsWithStatuses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_ListTransactionsWithStatuses_Call) RunAndReturn(run func(context.Context, ...arangodb.TransactionStatus) ([]arangodb.Transaction, error)) *Database_ListTransactionsWithStatuses_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function with given fields:
func (_m *Database) Name() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Database_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type Database_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *Database_Expecter) Name() *Database_Name_Call {
	return &Database_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *Database_Name_Call) Run(run func()) *Database_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Database_Name_Call) Return(_a0 string) *Database_Name_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Database_Name_Call) RunAndReturn(run func() string) *Database_Name_Call {
	_c.Call.Return(run)
	return _c
}

// Query provides a mock function with given fields: ctx, query, opts
func (_m *Database) Query(ctx context.Context, query string, opts *arangodb.QueryOptions) (arangodb.Cursor, error) {
	ret := _m.Called(ctx, query, opts)

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 arangodb.Cursor
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.QueryOptions) (arangodb.Cursor, error)); ok {
		return rf(ctx, query, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.QueryOptions) arangodb.Cursor); ok {
		r0 = rf(ctx, query, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Cursor)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.QueryOptions) error); ok {
		r1 = rf(ctx, query, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_Query_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Query'
type Database_Query_Call struct {
	*mock.Call
}

// Query is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - opts *arangodb.QueryOptions
func (_e *Database_Expecter) Query(ctx interface{}, query interface{}, opts interface{}) *Database_Query_Call {
	return &Database_Query_Call{Call: _e.mock.On("Query", ctx, query, opts)}
}

func (_c *Database_Query_Call) Run(run func(ctx context.Context, query string, opts *arangodb.QueryOptions)) *Database_Query_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.QueryOptions))
	})
	return _c
}

func (_c *Database_Query_Call) Return(_a0 arangodb.Cursor, _a1 error) *Database_Query_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_Query_Call) RunAndReturn(run func(context.Context, string, *arangodb.QueryOptions) (arangodb.Cursor, error)) *Database_Query_Call {
	_c.Call.Return(run)
	return _c
}

// QueryBatch provides a mock function with given fields: ctx, query, opts, result
func (_m *Database) QueryBatch(ctx context.Context, query string, opts *arangodb.QueryOptions, result interface{}) (arangodb.CursorBatch, error) {
	ret := _m.Called(ctx, query, opts, result)

	if len(ret) == 0 {
		panic("no return value specified for QueryBatch")
	}

	var r0 arangodb.CursorBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.QueryOptions, interface{}) (arangodb.CursorBatch, error)); ok {
		return rf(ctx, query, opts, result)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *arangodb.QueryOptions, interface{}) arangodb.CursorBatch); ok {
		r0 = rf(ctx, query, opts, result)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.CursorBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *arangodb.QueryOptions, interface{}) error); ok {
		r1 = rf(ctx, query, opts, result)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_QueryBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryBatch'
type Database_QueryBatch_Call struct {
	*mock.Call
}

// QueryBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - opts *arangodb.QueryOptions
//   - result interface{}
func (_e *Database_Expecter) QueryBatch(ctx interface{}, query interface{}, opts interface{}, result interface{}) *Database_QueryBatch_Call {
	return &Database_QueryBatch_Call{Call: _e.mock.On("QueryBatch", ctx, query, opts, result)}
}

func (_c *Database_QueryBatch_Call) Run(run func(ctx context.Context, query string, opts *arangodb.QueryOptions, result interface{})) *Database_QueryBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*arangodb.QueryOptions), args[3].(interface{}))
	})
	return _c
}

func (_c *Database_QueryBatch_Call) Return(_a0 arangodb.CursorBatch, _a1 error) *Database_QueryBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_QueryBatch_Call) RunAndReturn(run func(context.Context, string, *arangodb.QueryOptions, interface{}) (arangodb.CursorBatch, error)) *Database_QueryBatch_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function with given fields: ctx
func (_m *Database) Remove(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Database_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type Database_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) Remove(ctx interface{}) *Database_Remove_Call {
	return &Database_Remove_Call{Call: _e.mock.On("Remove", ctx)}
}

func (_c *Database_Remove_Call) Run(run func(ctx context.Context)) *Database_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Database_Remove_Call) Return(_a0 error) *Database_Remove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Database_Remove_Call) RunAndReturn(run func(context.Context) error) *Database_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Transaction provides a mock function with given fields: ctx, id
func (_m *Database) Transaction(ctx context.Context, id arangodb.TransactionID) (arangodb.Transaction, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Transaction")
	}

	var r0 arangodb.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.TransactionID) (arangodb.Transaction, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.TransactionID) arangodb.Transaction); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, arangodb.TransactionID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_Transaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transaction'
type Database_Transaction_Call struct {
	*mock.Call
}

// Transaction is a helper method to define mock.On call
//   - ctx context.Context
//   - id arangodb.TransactionID
func (_e *Database_Expecter) Transaction(ctx interface{}, id interface{}) *Database_Transaction_Call {
	return &Database_Transaction_Call{Call: _e.mock.On("Transaction", ctx, id)}
}

func (_c *Database_Transaction_Call) Run(run func(ctx context.Context, id arangodb.TransactionID)) *Database_Transaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.TransactionID))
	})
	return _c
}

func (_c *Database_Transaction_Call) Return(_a0 arangodb.Transaction, _a1 error) *Database_Transaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_Transaction_Call) RunAndReturn(run func(context.Context, arangodb.TransactionID) (arangodb.Transaction, error)) *Database_Transaction_Call {
	_c.Call.Return(run)
	return _c
}

// TransactionJS provides a mock function with given fields: ctx, options
func (_m *Database) TransactionJS(ctx context.Context, options arangodb.TransactionJSOptions) (interface{}, error) {
	ret := _m.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for TransactionJS")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.TransactionJSOptions) (interface{}, error)); ok {
		return rf(ctx, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.TransactionJSOptions) interface{}); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, arangodb.TransactionJSOptions) error); ok {
		r1 = rf(ctx, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_TransactionJS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransactionJS'
type Database_TransactionJS_Call struct {
	*mock.Call
}

// TransactionJS is a helper method to define mock.On call
//   - ctx context.Context
//   - options arangodb.TransactionJSOptions
func (_e *Database_Expecter) TransactionJS(ctx interface{}, options interface{}) *Database_TransactionJS_Call {
	return &Database_TransactionJS_Call{Call: _e.mock.On("TransactionJS", ctx, options)}
}

func (_c *Database_TransactionJS_Call) Run(run func(ctx context.Context, options arangodb.TransactionJSOptions)) *Database_TransactionJS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.TransactionJSOptions))
	})
	return _c
}

func (_c *Database_TransactionJS_Call) Return(_a0 interface{}, _a1 error) *Database_TransactionJS_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_TransactionJS_Call) RunAndReturn(run func(context.Context, arangodb.TransactionJSOptions) (interface{}, error)) *Database_TransactionJS_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateQuery provides a mock function with given fields: ctx, query
func (_m *Database) ValidateQuery(ctx context.Context, query string) error {
	ret := _m.Called(ctx, query)

	if len(ret) == 0 {
		panic("no return value specified for ValidateQuery")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, query)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Database_ValidateQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateQuery'
type Database_ValidateQuery_Call struct {
	*mock.Call
}

// ValidateQuery is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
func (_e *Database_Expecter) ValidateQuery(ctx interface{}, query interface{}) *Database_ValidateQuery_Call {
	return &Database_ValidateQuery_Call{Call: _e.mock.On("ValidateQuery", ctx, query)}
}

func (_c *Database_ValidateQuery_Call) Run(run func(ctx context.Context, query string)) *Database_ValidateQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Database_ValidateQuery_Call) Return(_a0 error) *Database_ValidateQuery_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Database_ValidateQuery_Call) RunAndReturn(run func(context.Context, string) error) *Database_ValidateQuery_Call {
	_c.Call.Return(run)
	return _c
}

// View provides a mock function with given fields: ctx, name
func (_m *Database) View(ctx context.Context, name string) (arangodb.View, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for View")
	}

	var r0 arangodb.View
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (arangodb.View, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) arangodb.View); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.View)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_View_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'View'
type Database_View_Call struct {
	*mock.Call
}

// View is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Database_Expecter) View(ctx interface{}, name interface{}) *Database_View_Call {
	return &Database_View_Call{Call: _e.mock.On("View", ctx, name)}
}

func (_c *Database_View_Call) Run(run func(ctx context.Context, name string)) *Database_View_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Database_View_Call) Return(_a0 arangodb.View, _a1 error) *Database_View_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_View_Call) RunAndReturn(run func(context.Context, string) (arangodb.View, error)) *Database_View_Call {
	_c.Call.Return(run)
	return _c
}

// ViewExists provides a mock function with given fields: ctx, name
func (_m *Database) ViewExists(ctx context.Context, name string) (bool, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for ViewExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_ViewExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ViewExists'
type Database_ViewExists_Call struct {
	*mock.Call
}

// ViewExists is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Database_Expecter) ViewExists(ctx interface{}, name interface{}) *Database_ViewExists_Call {
	return &Database_ViewExists_Call{Call: _e.mock.On("ViewExists", ctx, name)}
}

func (_c *Database_ViewExists_Call) Run(run func(ctx context.Context, name string)) *Database_ViewExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Database_ViewExists_Call) Return(_a0 bool, _a1 error) *Database_ViewExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_ViewExists_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *Database_ViewExists_Call {
	_c.Call.Return(run)
	return _c
}

// Views provides a mock function with given fields: ctx
func (_m *Database) Views(ctx context.Context) (arangodb.ViewsResponseReader, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Views")
	}

	var r0 arangodb.ViewsResponseReader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (arangodb.ViewsResponseReader, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) arangodb.ViewsResponseReader); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(arangodb.ViewsResponseReader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_Views_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Views'
type Database_Views_Call struct {
	*mock.Call
}

// Views is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) Views(ctx interface{}) *Database_Views_Call {
	return &Database_Views_Call{Call: _e.mock.On("Views", ctx)}
}

func (_c *Database_Views_Call) Run(run func(ctx context.Context)) *Database_Views_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Database_Views_Call) Return(_a0 arangodb.ViewsResponseReader, _a1 error) *Database_Views_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_Views_Call) RunAndReturn(run func(context.Context) (arangodb.ViewsResponseReader, error)) *Database_Views_Call {
	_c.Call.Return(run)
	return _c
}

// ViewsAll provides a mock function with given fields: ctx
func (_m *Database) ViewsAll(ctx context.Context) ([]arangodb.View, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ViewsAll")
	}

	var r0 []arangodb.View
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]arangodb.View, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []arangodb.View); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]arangodb.View)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Database_ViewsAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ViewsAll'
type Database_ViewsAll_Call struct {
	*mock.Call
}

// ViewsAll is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Database_Expecter) ViewsAll(ctx interface{}) *Database_ViewsAll_Call {
	return &Database_ViewsAll_Call{Call: _e.mock.On("ViewsAll", ctx)}
}

func (_c *Database_ViewsAll_Call) Run(run func(ctx context.Context)) *Database_ViewsAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Database_ViewsAll_Call) Return(_a0 []arangodb.View, _a1 error) *Database_ViewsAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Database_ViewsAll_Call) RunAndReturn(run func(context.Context) ([]arangodb.View, error)) *Database_ViewsAll_Call {
	_c.Call.Return(run)
	return _c
}

// WithTransaction provides a mock function with given fields: ctx, cols, opts, commitOptions, abortOptions, w
func (_m *Database) WithTransaction(ctx context.Context, cols arangodb.TransactionCollections, opts *arangodb.BeginTransactionOptions, commitOptions *arangodb.CommitTransactionOptions, abortOptions *arangodb.AbortTransactionOptions, w arangodb.TransactionWrap) error {
	ret := _m.Called(ctx, cols, opts, commitOptions, abortOptions, w)

	if len(ret) == 0 {
		panic("no return value specified for WithTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, arangodb.TransactionCollections, *arangodb.BeginTransactionOptions, *arangodb.CommitTransactionOptions, *arangodb.AbortTransactionOptions, arangodb.TransactionWrap) error); ok {
		r0 = rf(ctx, cols, opts, commitOptions, abortOptions, w)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Database_WithTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTransaction'
type Database_WithTransaction_Call struct {
	*mock.Call
}

// WithTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - cols arangodb.TransactionCollections
//   - opts *arangodb.BeginTransactionOptions
//   - commitOptions *arangodb.CommitTransactionOptions
//   - abortOptions *arangodb.AbortTransactionOptions
//   - w arangodb.TransactionWrap
func (_e *Database_Expecter) WithTransaction(ctx interface{}, cols interface{}, opts interface{}, commitOptions interface{}, abortOptions interface{}, w interface{}) *Database_WithTransaction_Call {
	return &Database_WithTransaction_Call{Call: _e.mock.On("WithTransaction", ctx, cols, opts, commitOptions, abortOptions, w)}
}

func (_c *Database_WithTransaction_Call) Run(run func(ctx context.Context, cols arangodb.TransactionCollections, opts *arangodb.BeginTransactionOptions, commitOptions *arangodb.CommitTransactionOptions, abortOptions *arangodb.AbortTransactionOptions, w arangodb.TransactionWrap)) *Database_WithTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(arangodb.TransactionCollections), args[2].(*arangodb.BeginTransactionOptions), args[3].(*arangodb.CommitTransactionOptions), args[4].(*arangodb.AbortTransactionOptions), args[5].(arangodb.TransactionWrap))
	})
	return _c
}

func (_c *Database_WithTransaction_Call) Return(_a0 error) *Database_WithTransaction_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Database_WithTransaction_Call) RunAndReturn(run func(context.Context, arangodb.TransactionCollections, *arangodb.BeginTransactionOptions, *arangodb.CommitTransactionOptions, *arangodb.AbortTransactionOptions, arangodb.TransactionWrap) error) *Database_WithTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// NewDatabase creates a new instance of Database. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDatabase(t interface {
	mock.TestingT
	Cleanup(func())
}) *Database {
	mock := &Database{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
